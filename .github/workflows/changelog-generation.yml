# ============================================================
# üìã Profile Weather View: Changelog Generation Workflow
# ============================================================

name: "üìã Changelog Generation"

# ============================================================
# üöÄ Workflow triggers for automatic and manual execution
# ============================================================

on:
  push:
    branches:
      - master                                                   # Trigger on push to master branch
    paths:
      - 'src/**'                                                 # Trigger on changes in source code
      - 'package.json'                                           # Trigger on changes to dependencies
      - 'release-please-config.json'                             # Trigger on changes to release configuration
      - '.release-please-manifest.json'                          # Trigger on changes to version manifest

  workflow_dispatch:
    inputs:
      version:
        description: "Specify version for changelog (optional)"
        required: false
        type: string
      force:
        description: "Force full changelog regeneration"
        type: boolean
        default: false
      debug:
        description: "Enable verbose logging"
        type: boolean
        default: false

# ============================================================
# üîí Prevent redundant executions (Ensures single execution)
# ============================================================
concurrency:
  group: ${{ github.workflow }}-${{ github.run_id }}
  cancel-in-progress: false

# ============================================================
# üîí Workflow permissions (Least privilege principle)
# ============================================================

permissions:
  contents: write                                                # Allow writing changes to the changelog file
  pull-requests: write                                           # Allow updates to pull requests if needed

# ============================================================
# üåç Global environment variables
# ============================================================

env:
  BUN_VERSION: "package.json"                                    # Bun version from package.json
  CHANGELOG_PATH: "CHANGELOG.md"                                 # Default path to the changelog file
  TIMEZONE: "UTC"                                                # Default timezone for logging
  FORCE_REGENERATE: ${{ github.event.inputs.force == 'true' }}   # Flag for full regeneration
  DEBUG_MODE: ${{ github.event.inputs.debug == 'true' }}         # Flag to enable debug mode
  NODE_OPTIONS: "--max-old-space-size=4096"                      # Prevents memory issues with large repositories
  ACTIONS_CACHE_KEY_PREFIX: "v3"                                 # Updated cache key prefix for new cache service
  WORKFLOW_TIMESTAMP: ${{ github.run_id }}                       # Using run_id as a timestamp alternative

jobs:
  # ============================================================
  # üîç Job 1: Preflight Validation (checks environment readiness)
  # ============================================================

  validate-prerequisites:
    name: "üîç Preflight Validation"
    runs-on: ubuntu-latest # Using latest runner version to ensure compatibility with new cache service
    outputs:
      should_proceed: ${{ steps.check-requirements.outputs.should_proceed }}
      repo_state: ${{ steps.repo-state.outputs.state }}

    steps:
      # Step to checkout the repository and fetch full history for changelog
      - name: "‚¨áÔ∏è Checkout Repository"
        uses: actions/checkout@v4
        with:
          fetch-depth: 0  # Fetch complete history for accurate changelog generation

      # Step to log the execution context for debugging and tracking purposes
      - name: "üîç Log Execution Context"
        run: |
          echo "::group::Execution Context"
          echo "üîπ Run ID: ${{ github.run_id }}"
          echo "üîπ Workflow: ${{ github.workflow }}"
          echo "üîπ Repository: ${{ github.repository }}"
          echo "üîπ Trigger: ${{ github.event_name }}"
          echo "üîπ Debug Mode: ${{ env.DEBUG_MODE == 'true' && 'Enabled' || 'Disabled' }}"
          echo "üîπ Started At: $(date -u '+%Y-%m-%d %H:%M:%S UTC')"
          echo "::endgroup::"

      # Step to check for required files (critical for changelog generation)
      - name: "üìë Check Required Files"
        id: check-requirements
        run: |
          REQUIRED_FILES=( ".release-please-manifest.json" "release-please-config.json" "package.json" )
          MISSING_FILES=()
          for file in "${REQUIRED_FILES[@]}"; do
            if [[ ! -f "$file" ]]; then
              MISSING_FILES+=("$file")
            fi
          done
          if [[ ${#MISSING_FILES[@]} -gt 0 ]]; then
            echo "::error::Missing critical files: ${MISSING_FILES[*]}"
            echo "should_proceed=false" >> $GITHUB_OUTPUT
            exit 1
          fi
          echo "::notice::All prerequisite files are present"
          echo "should_proceed=true" >> $GITHUB_OUTPUT

      # Step to evaluate the repository state (based on commit history, branch count, and file count)
      - name: "üîÑ Evaluate Repository State"
        id: repo-state
        if: steps.check-requirements.outputs.should_proceed == 'true'
        run: |
          COMMIT_COUNT=$(git rev-list --count HEAD)
          BRANCH_COUNT=$(git branch -r | wc -l)
          FILE_COUNT=$(git ls-files | wc -l)

          # Combined complexity assessment
          if [[ $COMMIT_COUNT -lt 5 ]]; then
            echo "state=minimal" >> $GITHUB_OUTPUT
            echo "::notice::Repository has minimal history ($COMMIT_COUNT commits)"
          elif [[ $BRANCH_COUNT -gt 10 || $FILE_COUNT -gt 1000 ]]; then
            echo "state=complex" >> $GITHUB_OUTPUT
            echo "::notice::Repository has complex structure ($BRANCH_COUNT branches, $FILE_COUNT files)"
          else
            echo "state=standard" >> $GITHUB_OUTPUT
            echo "::notice::Repository has standard structure"
          fi

  # ============================================================
  # üöÄ Job 2: Changelog Generation
  # ============================================================

  generate-changelog:
    name: "üöÄ Changelog Generation"
    needs: validate-prerequisites
    if: needs.validate-prerequisites.outputs.should_proceed == 'true'
    runs-on: ubuntu-latest # Using latest runner version to ensure compatibility with new cache service
    timeout-minutes: 10
    outputs:
      change_count: ${{ steps.generate.outputs.change_count }}
      gen_status: ${{ steps.generate.outputs.gen_status }}
      changes_committed: ${{ steps.commit.outputs.changes_committed }}
      commit_message: ${{ steps.commit.outputs.commit_message }}

    steps:
      # Step to record the start time for measuring duration
      - name: "‚è±Ô∏è Record Start Time"
        id: start-timer
        run: echo "start_time=$(date +%s)" >> $GITHUB_OUTPUT

      # Step to checkout the repository again for the changelog generation
      - name: "‚¨áÔ∏è Checkout Repository"
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      # Step to extract Bun version from package.json
      - name: "üìã Extract Bun Version"
        id: extract-bun-version
        run: |
          BUN_VERSION=$(node -e "const pkg = require('./package.json'); const pm = pkg.packageManager || ''; const version = pm.match(/bun@(.*)/); console.log(version ? version[1] : '1.2.9')")
          echo "BUN_VERSION=$BUN_VERSION" >> $GITHUB_ENV
          echo "::notice::Using Bun version $BUN_VERSION from package.json"

      # Step to set up Bun runtime for executing changelog generation scripts
      - name: "üß∞ Setup Bun Runtime"
        uses: oven-sh/setup-bun@v2
        with:
          bun-version: ${{ env.BUN_VERSION }}
        continue-on-error: false  # Fail the workflow if Bun setup fails - this is critical

      # Step to cache Bun dependencies to speed up workflow execution - optimized caching strategy
      - name: "üíæ Cache Bun Dependencies"
        id: cache-bun-deps
        uses: actions/cache@v4
        with:
          path: |
            ~/.bun/install/cache
            node_modules
            .bun
          key: ${{ runner.os }}-bun-${{ env.ACTIONS_CACHE_KEY_PREFIX }}-${{ hashFiles('**/bun.lockb', '**/package.json') }}
          restore-keys: |
            ${{ runner.os }}-bun-${{ env.ACTIONS_CACHE_KEY_PREFIX }}-
            ${{ runner.os }}-bun-
          enableCrossOsArchive: false
          fail-on-cache-miss: false

      # Fallback in case cache fails
      - name: "üì¶ Cache Status Check"
        run: |
          if [ "${{ steps.cache-bun-deps.outcome }}" != "success" ]; then
            echo "::warning::Bun dependency cache operation failed or was skipped. Using fresh install."
            echo "CACHE_HIT=false" >> $GITHUB_ENV
          else
            echo "::notice::Bun dependencies cache ${{ steps.cache-bun-deps.outputs.cache-hit == 'true' && 'hit' || 'miss' }}"
          fi

      # Step to verify that the Bun runtime is installed and configured correctly
      - name: "üîç Verify Bun Installation"
        run: |
          echo "::group::Runtime Verification"
          RAW_VERSION=$(bun --version)
          BUN_VERSION=$(echo "$RAW_VERSION" | grep -oE '[0-9]+\.[0-9]+\.[0-9]+')
          echo "üîπ Raw Bun Version: $RAW_VERSION"
          echo "üîπ Parsed Bun Version: $BUN_VERSION"

          # Validate version format with improved error message
          if [[ ! "$BUN_VERSION" =~ ^[0-9]+\.[0-9]+\.[0-9]+$ ]]; then
            echo "::error::Invalid Bun version format: $RAW_VERSION. Expected semver format (e.g., 1.0.0)."
            exit 1
          fi

          # Parse version parts and check minimum required version
          IFS='.' read -r MAJOR MINOR PATCH <<< "$BUN_VERSION"
          if (( MAJOR < 1 )); then
            echo "::warning::Bun version is below recommended minimum (1.0.0). Current: $BUN_VERSION"
          else
            echo "üîπ Bun version $BUN_VERSION meets minimum requirements"
          fi
          echo "::endgroup::"

      # Step to resolve the version from the manual input or release manifest
      - name: "üìã Resolve Version"
        id: version-validation
        run: |
          if [[ -n "${{ github.event.inputs.version }}" ]]; then
            VERSION="${{ github.event.inputs.version }}"
            SOURCE="manual input"
          else
            # Get the docs component version from the manifest
            if jq -e '.docs' .release-please-manifest.json > /dev/null; then
              VERSION=$(jq -r '.docs' .release-please-manifest.json)
              SOURCE="release manifest (docs component)"
            # Fallback to codebase component if docs component not found
            elif jq -e '.codebase' .release-please-manifest.json > /dev/null; then
              VERSION=$(jq -r '.codebase' .release-please-manifest.json)
              SOURCE="release manifest (codebase component)"
            else
              # Fallback to a default version if neither component is found
              echo "::error::No component versions found in release-please-manifest.json"
              exit 1
            fi
          fi

          # Validate version format - improved error handling
          if [[ ! "$VERSION" =~ ^[0-9]+\.[0-9]+\.[0-9]+(-[a-zA-Z0-9\.]+)?$ ]]; then
            echo "::error::Invalid semantic version format: $VERSION. Cannot proceed with changelog generation."
            exit 1
          else
            echo "::notice::Detected Version: $VERSION (Source: $SOURCE)"
            echo "version=$VERSION" >> $GITHUB_OUTPUT
            echo "source=$SOURCE" >> $GITHUB_OUTPUT
          fi

      # Step to prepare the environment for changelog generation (install dependencies)
      - name: "üì¶ Prepare Environment"
        run: |
          echo "::group::Environment Preparation"
          bun add --exact @commitlint/parse --no-save
          mkdir -p src/docs/changelog
          if [[ ! -f "${{ env.CHANGELOG_PATH }}" ]]; then
            echo -e "# Changelog\n\nAll notable changes to this project will be documented in this file." > "${{ env.CHANGELOG_PATH }}"
          fi
          echo "::endgroup::"

      # Step to backup existing changelog if force regeneration is enabled
      - name: "üìë Backup Existing Changelog"
        id: backup-changelog
        if: env.FORCE_REGENERATE == 'true' && hashFiles(env.CHANGELOG_PATH) != ''
        run: |
          BACKUP_PATH="${{ env.CHANGELOG_PATH }}.backup-$(date +%Y%m%d-%H%M%S)"
          cp "${{ env.CHANGELOG_PATH }}" "$BACKUP_PATH"
          echo "::notice::Created backup of existing changelog at $BACKUP_PATH"
          echo "backup_path=$BACKUP_PATH" >> $GITHUB_OUTPUT

      # Simplified changelog generation script - extracted complex logic to separate file
      - name: "üìù Create Changelog Generation Script"
        run: |
          mkdir -p .github/scripts
          cat > .github/scripts/generate-changelog.sh << 'EOL'
          #!/bin/bash
          set -e

          # Input parameters
          VERSION="$1"
          REPO_STATE="$2"
          FORCE_FLAG="$3"
          DEBUG_FLAG="$4"
          OUTPUT_LOG="/tmp/changelog-generator-$(date +%s).log"

          # Execute with proper error handling
          echo "Starting changelog generation for version $VERSION (repo state: $REPO_STATE)"

          # Create fallback changelog with basic structure if needed
          if [[ ! -f "CHANGELOG.MD" || "$FORCE_FLAG" == "--force" ]]; then
            echo -e "# Changelog\n\nAll notable changes to this project will be documented in this file.\n\n## [$VERSION] - $(date +'%Y-%m-%d')\n\n### Added\n- Initial release\n" > "CHANGELOG.MD"
            echo "Created fallback changelog file"
          fi

          # Run the generator
          set +e
          bun run src/docs/changelog/changelog-generator.ts \
            "$VERSION" \
            $FORCE_FLAG $DEBUG_FLAG \
            --repo-state=$REPO_STATE \
            2>&1 | tee $OUTPUT_LOG
          GENERATION_STATUS=$?
          set -e

          # Process results
          CHANGE_COUNT=0
          GEN_STATUS="unknown"

          if [[ -f "$OUTPUT_LOG" ]]; then
            if grep -q "Successfully parsed commit:" "$OUTPUT_LOG"; then
              CHANGE_COUNT=$(grep -c "Successfully parsed commit:" "$OUTPUT_LOG" || echo "0")
              CHANGE_COUNT=$((CHANGE_COUNT))
              GEN_STATUS="success"
            elif grep -q "No new commits to process" "$OUTPUT_LOG"; then
              CHANGE_COUNT=0
              GEN_STATUS="success"
            fi
          fi

          # Output results for parsing by parent workflow
          echo "CHANGE_COUNT=$CHANGE_COUNT"
          echo "GEN_STATUS=$GEN_STATUS"
          echo "GENERATION_STATUS=$GENERATION_STATUS"

          # Exit with original status code
          exit $GENERATION_STATUS
          EOL

          chmod +x .github/scripts/generate-changelog.sh

      # Step to generate the changelog based on the version and repo state - simplified using external script
      - name: "üîÑ Generate Changelog"
        id: generate
        run: |
          echo "::group::Changelog Generation Process"

          # Setup timeout monitoring
          TIMESTAMP=$(date +%s)
          MAX_DURATION=540  # 9 minutes
          (
            # Background process to monitor execution time
            while true; do
              sleep 30
              CURRENT=$(date +%s)
              ELAPSED=$((CURRENT - TIMESTAMP))
              if [[ $ELAPSED -gt $MAX_DURATION ]]; then
                echo "::warning::Changelog generation approaching timeout limit ($ELAPSED seconds). Process may be terminated."
                break
              elif [[ $ELAPSED -gt 300 ]]; then
                # After 5 minutes, show a warning
                echo "::warning::Changelog generation running for $ELAPSED seconds. This is longer than expected."
                break
              fi
            done
          ) &
          MONITOR_PID=$!

          # Run script with proper parameters
          FORCE_FLAG=""
          if [[ "${{ env.FORCE_REGENERATE }}" == "true" ]]; then FORCE_FLAG="--force"; fi
          DEBUG_FLAG=""
          if [[ "${{ env.DEBUG_MODE }}" == "true" ]]; then DEBUG_FLAG="--debug"; fi

          # Call the extracted script
          SCRIPT_OUTPUT=$(.github/scripts/generate-changelog.sh \
            "${{ steps.version-validation.outputs.version }}" \
            "${{ needs.validate-prerequisites.outputs.repo_state }}" \
            "$FORCE_FLAG" \
            "$DEBUG_FLAG")

          # Kill the monitoring process
          kill $MONITOR_PID 2>/dev/null || true

          # Parse script output
          CHANGE_COUNT=$(echo "$SCRIPT_OUTPUT" | grep "CHANGE_COUNT=" | cut -d= -f2 || echo "0")
          GEN_STATUS=$(echo "$SCRIPT_OUTPUT" | grep "GEN_STATUS=" | cut -d= -f2 || echo "unknown")
          GENERATION_STATUS=$(echo "$SCRIPT_OUTPUT" | grep "GENERATION_STATUS=" | cut -d= -f2 || echo "1")

          echo "change_count=${CHANGE_COUNT:-0}" >> $GITHUB_OUTPUT
          echo "gen_status=${GEN_STATUS:-unknown}" >> $GITHUB_OUTPUT

          if [[ "$GENERATION_STATUS" != "0" ]]; then
            echo "::warning::Changelog generation command exited with code: $GENERATION_STATUS"

            if [[ -f "${{ env.CHANGELOG_PATH }}" ]]; then
              echo "::notice::Existing changelog file is available"
              # Attempt to restore from backup if available
              if [[ "${{ steps.backup-changelog.outcome }}" == "success" && -n "${{ steps.backup-changelog.outputs.backup_path }}" ]]; then
                echo "::notice::Restoring changelog from backup"
                cp "${{ steps.backup-changelog.outputs.backup_path }}" "${{ env.CHANGELOG_PATH }}"
              fi
              echo "gen_status=recovered" >> $GITHUB_OUTPUT
            else
              echo "::error::Failed to generate changelog and no existing file available"
              exit 1
            fi
          fi

          echo "::notice::Successfully processed ${CHANGE_COUNT:-0} commit entries"
          echo "::endgroup::"

      # Step to commit and push the changelog updates if any changes were detected
      - name: "üì§ Commit Changelog Updates"
        id: commit
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          echo "::group::Git Operations"
          # Set up git configuration with better traceability
          git config user.name 'github-actions[bot]'
          git config user.email '${{ github.actor }}@users.noreply.github.com'

          if [[ -n "$(git status --porcelain ${{ env.CHANGELOG_PATH }})" ]]; then
            git add ${{ env.CHANGELOG_PATH }}

            # Build commit message with proper suffixes
            MSG_SUFFIX=""
            if [[ "${{ env.FORCE_REGENERATE }}" == "true" ]]; then MSG_SUFFIX="$MSG_SUFFIX (full regeneration)"; fi
            if [[ "${{ steps.version-validation.outputs.source }}" == "manual input" ]]; then MSG_SUFFIX="$MSG_SUFFIX [manual]"; fi
            COMMIT_MSG="docs(changelog): update for v${{ steps.version-validation.outputs.version }}$MSG_SUFFIX"

            git commit -m "$COMMIT_MSG"
            echo "commit_message=$COMMIT_MSG" >> $GITHUB_OUTPUT  # Capture the commit message

            if git push; then
              echo "::notice::Successfully pushed changelog updates"
              echo "changes_committed=true" >> $GITHUB_OUTPUT
            else
              echo "::error::Push failed"
              exit 1
            fi
          else
            echo "üîπ No changelog updates detected"
            echo "changes_committed=false" >> $GITHUB_OUTPUT
            echo "commit_message=No changes" >> $GITHUB_OUTPUT
          fi
          echo "::endgroup::"

      # Step to generate a final report on the changelog generation process
      - name: "üìä Generation Report"
        run: |
          END_TIME=$(date +%s)
          START_TIME=${{ steps.start-timer.outputs.start_time }}
          DURATION=$((END_TIME - START_TIME))

          echo "::notice::Changelog Generation Duration: $DURATION seconds"
          CHANGES_COMMITTED=${{ steps.commit.outputs.changes_committed }}
          if [[ "$CHANGES_COMMITTED" == "true" ]]; then
            echo "::notice::Changelog updates were successfully committed!"
          else
            echo "::warning::No changes to commit for the changelog."
          fi

          if [[ "$CHANGES_COMMITTED" == "true" ]]; then
            COMMIT_MSG="${{ steps.commit.outputs.commit_message }}"
            echo "::notice::Commit Message: $COMMIT_MSG"
          fi

          if [[ $DURATION -gt 180 ]]; then
            echo "::warning::Changelog generation took more than 3 minutes ($DURATION seconds). Please review the logs for any issues."
          else
            echo "::notice::Changelog generation completed successfully within $DURATION seconds."
          fi

          # Export metrics for monitoring
          echo "workflow_duration=$DURATION" >> $GITHUB_ENV

      # Step to save logs as artifacts for debugging
      - name: "üìÅ Save Logs as Artifacts"
        if: always() && (env.DEBUG_MODE == 'true' || failure())
        uses: actions/upload-artifact@v4
        with:
          name: changelog-generation-logs-${{ github.run_id }}
          path: |
            /tmp/changelog-generator-*.log
            ${{ steps.backup-changelog.outputs.backup_path }}
          retention-days: 7
          if-no-files-found: ignore
          compression-level: 9  # Maximum compression

  # ============================================================
  # üìä Job 3: Workflow Summary
  # ============================================================
  summary:
    name: "üìä Workflow Summary"
    needs: [validate-prerequisites, generate-changelog]
    if: always()
    runs-on: ubuntu-latest
    steps:
      - name: "üìë Generate Workflow Summary"
        run: |
          echo "# Changelog Generation Summary" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "## Status" >> $GITHUB_STEP_SUMMARY
          echo "- Preflight Validation: ${{ needs.validate-prerequisites.result }}" >> $GITHUB_STEP_SUMMARY
          echo "- Changelog Generation: ${{ needs.generate-changelog.result }}" >> $GITHUB_STEP_SUMMARY

          if [[ "${{ needs.generate-changelog.result }}" == "success" ]]; then
            echo "- Changes Processed: ${{ needs.generate-changelog.outputs.change_count || '0' }}" >> $GITHUB_STEP_SUMMARY
            echo "- Generation Status: ${{ needs.generate-changelog.outputs.gen_status || 'unknown' }}" >> $GITHUB_STEP_SUMMARY

            if [[ "${{ needs.generate-changelog.outputs.changes_committed }}" == "true" ]]; then
              echo "- Commit Status: Changes committed and pushed" >> $GITHUB_STEP_SUMMARY
              echo "- Commit Message: \`${{ needs.generate-changelog.outputs.commit_message }}\`" >> $GITHUB_STEP_SUMMARY
            else
              echo "- Commit Status: No changes to commit" >> $GITHUB_STEP_SUMMARY
            fi
          fi

          echo "" >> $GITHUB_STEP_SUMMARY
          echo "## Configuration" >> $GITHUB_STEP_SUMMARY
          echo "- Repository State: ${{ needs.validate-prerequisites.outputs.repo_state || 'unknown' }}" >> $GITHUB_STEP_SUMMARY
          echo "- Force Regeneration: ${{ env.FORCE_REGENERATE == 'true' && 'Yes' || 'No' }}" >> $GITHUB_STEP_SUMMARY
          echo "- Debug Mode: ${{ env.DEBUG_MODE == 'true' && 'Enabled' || 'Disabled' }}" >> $GITHUB_STEP_SUMMARY
