# Documentation Release Management Workflow
name: "📚 Documentation Release Management"

# ============================================================
# 🚀 Workflow triggers for documentation updates
# ============================================================
on:
  # Trigger on documentation and configuration changes
  push:
    branches:
      - master                                     # Main branch for documentation
    paths:
      - 'src/docs/**'                              # Documentation source files
      - 'release-please-config.json'               # Release configuration
      - '.release-please-manifest.json'            # Version manifest
      - 'meta.json'                                # Site metadata

  # Manual workflow dispatch for immediate releases
  workflow_dispatch:
    inputs:
      dry_run:
        description: "Simulate release without publishing"
        type: boolean
        default: false
      debug:
        description: "Enable debug logging"
        type: boolean
        default: false

# ============================================================
# 🔒 Prevent redundant executions
# ============================================================
concurrency:
  group: ${{ github.workflow }}-${{ github.run_id }}
  cancel-in-progress: false

# ============================================================
# 🔒 Required permissions
# ============================================================
permissions:
  contents: write                                 # For releases and tags
  pull-requests: write                            # For creating PRs
  pages: write                                    # For GitHub Pages deployment
  id-token: write                                 # For Pages authentication
  issues: read                                    # For linking issues in release notes

# ============================================================
# 🌍 Global environment variables
# ============================================================
env:
  BUN_VERSION: "package.json"                     # Bun version from package.json
  DOCS_SOURCE_DIR: "src/docs"
  DOCS_OUTPUT_DIR: "src/docs/.vitepress/dist"
  DEBUG_MODE: ${{ github.event.inputs.debug == 'true' }}
  DRY_RUN: ${{ github.event.inputs.dry_run == 'true' }}
  EXECUTION_ID: ${{ github.run_id }}-${{ github.run_attempt }}
  NODE_OPTIONS: "--max-old-space-size=4096"       # Prevents memory issues with large builds

# ============================================================
# Jobs
# ============================================================
jobs:
  # ============================================================
  # Preflight Checks
  # ============================================================
  preflight:
    name: "🔍 Preflight Checks"
    runs-on: ubuntu-latest
    timeout-minutes: 3
    outputs:
      proceed: ${{ steps.validation.outputs.proceed }}
      config_valid: ${{ steps.config-validation.outputs.valid }}

    steps:
      - name: "⬇️ Checkout Repository"
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: "🔍 Log Execution Context"
        run: |
          echo "::group::Execution Context"
          echo "🔹 Run ID: ${{ env.EXECUTION_ID }}"
          echo "🔹 Workflow: ${{ github.workflow }}"
          echo "🔹 Repository: ${{ github.repository }}"
          echo "🔹 Trigger: ${{ github.event_name }}"
          echo "🔹 Debug Mode: ${{ env.DEBUG_MODE == 'true' && 'Enabled' || 'Disabled' }}"
          echo "🔹 Dry Run: ${{ env.DRY_RUN == 'true' && 'Enabled' || 'Disabled' }}"
          echo "::endgroup::"

      - name: "📑 Validate Required Files"
        id: validation
        run: |
          echo "::group::File Validation"
          # Verify required files exist
          REQUIRED_FILES=(
            "release-please-config.json"
            ".release-please-manifest.json"
            "package.json"
            "meta.json"
          )

          MISSING_FILES=()
          for file in "${REQUIRED_FILES[@]}"; do
            if [[ -f "$file" ]]; then
              echo "🔹 Found: $file"
            else
              echo "❌ Missing: $file"
              MISSING_FILES+=("$file")
            fi
          done

          if [[ ${#MISSING_FILES[@]} -gt 0 ]]; then
            echo "::error::Missing required files: ${MISSING_FILES[*]}"
            echo "proceed=false" >> $GITHUB_OUTPUT
            exit 1
          fi

          # Validate documentation directory
          if [[ ! -d "${{ env.DOCS_SOURCE_DIR }}" ]]; then
            echo "::error::Documentation directory not found: ${{ env.DOCS_SOURCE_DIR }}"
            echo "proceed=false" >> $GITHUB_OUTPUT
            exit 1
          fi

          echo "proceed=true" >> $GITHUB_OUTPUT
          echo "::notice::Repository file structure validation successful"
          echo "::endgroup::"

      - name: "🔄 Validate Release Configuration"
        id: config-validation
        if: steps.validation.outputs.proceed == 'true'
        run: |
          echo "::group::Configuration Validation"
          # Validate release-please config
          if jq -e '.packages.docs' release-please-config.json > /dev/null; then
            echo "🔹 Documentation component found in release-please config"
            echo "valid=true" >> $GITHUB_OUTPUT
          else
            echo "::error::Documentation component not configured in release-please-config.json"
            echo "valid=false" >> $GITHUB_OUTPUT
            exit 1
          fi
          echo "::endgroup::"

  # ============================================================
  # Release Please
  # ============================================================
  release:
    name: "🚀 Release Please"
    needs: preflight
    if: needs.preflight.outputs.proceed == 'true' && needs.preflight.outputs.config_valid == 'true'
    runs-on: ubuntu-latest
    timeout-minutes: 5
    outputs:
      releases_created: ${{ steps.release.outputs.releases_created }}
      tag_name: ${{ steps.release.outputs.tag_name }}
      version: ${{ steps.version.outputs.version }}
      release_url: ${{ steps.release.outputs.html_url }}
      pr_url: ${{ steps.release.outputs.pr }}

    steps:
      - name: "⬇️ Checkout Repository"
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: "🔄 Run Release Please"
        id: release
        uses: googleapis/release-please-action@v4
        env:
          DEBUG: ${{ env.DEBUG_MODE == 'true' && 'true' || '' }}
        with:
          token: ${{ secrets.GITHUB_TOKEN }}
          config-file: release-please-config.json
          manifest-file: .release-please-manifest.json
          skip-github-release: ${{ env.DRY_RUN == 'true' }}
          path: "."

      - name: "🏷️ Extract Version Information"
        id: version
        if: steps.release.outputs.releases_created
        run: |
          TAG="${{ steps.release.outputs.tag_name }}"
          VERSION="${TAG#*v}"  # Handle potential component prefix
          echo "version=$VERSION" >> $GITHUB_OUTPUT
          echo "::notice::New documentation release: $VERSION"

      - name: "📊 Log Release Information"
        if: steps.release.outputs.releases_created
        run: |
          echo "::group::Release Information"
          echo "🔹 Release Created: Yes"
          echo "🔹 Tag Name: ${{ steps.release.outputs.tag_name }}"
          echo "🔹 Version: ${{ steps.version.outputs.version }}"
          echo "🔹 Release URL: ${{ steps.release.outputs.html_url }}"
          echo "::endgroup::"

  # ============================================================
  # Build and Deploy
  # ============================================================
  build-deploy:
    name: "📚 Build & Deploy Documentation"
    needs: release
    if: needs.release.outputs.releases_created == 'true'
    runs-on: ubuntu-latest
    timeout-minutes: 10
    outputs:
      deployment_url: ${{ steps.deployment.outputs.page_url }}

    steps:
      - name: "⬇️ Checkout Repository"
        uses: actions/checkout@v4
        with:
          ref: ${{ needs.release.outputs.tag_name }}
          fetch-depth: 1

      - name: "📋 Extract Bun Version"
        id: extract-bun-version
        run: |
          BUN_VERSION=$(node -e "const pkg = require('./package.json'); const pm = pkg.packageManager || ''; const version = pm.match(/bun@(.*)/); console.log(version ? version[1] : '1.2.9')")
          echo "BUN_VERSION=$BUN_VERSION" >> $GITHUB_ENV
          echo "::notice::Using Bun version $BUN_VERSION from package.json"

      - name: "🧰 Setup Bun Runtime"
        uses: oven-sh/setup-bun@v2
        with:
          bun-version: ${{ env.BUN_VERSION }}

      - name: "💾 Cache Dependencies"
        uses: actions/cache@v4
        with:
          path: |
            ~/.bun/install/cache
            node_modules
          key: ${{ runner.os }}-bun-v4-${{ hashFiles('**/bun.lockb', '**/package.json') }}
          restore-keys: |
            ${{ runner.os }}-bun-v4-
          enableCrossOsArchive: false
          fail-on-cache-miss: false

      - name: "📦 Install Dependencies"
        run: |
          echo "::group::Dependency Installation"
          bun install --frozen-lockfile
          echo "::endgroup::"

      - name: "⚙️ Configure GitHub Pages"
        uses: actions/configure-pages@v5

      - name: "🔄 Update Version Metadata"
        id: update-metadata
        run: |
          echo "::group::Metadata Update"
          VERSION="${{ needs.release.outputs.version }}"
          TIMESTAMP=$(date -u '+%Y-%m-%dT%H:%M:%SZ')
          DATE=$(date '+%B %d, %Y')

          # Parse version components
          IFS='.' read -r MAJOR MINOR PATCH <<< "$VERSION"
          echo "🔹 Version components: Major=$MAJOR, Minor=$MINOR, Patch=$PATCH"

          # Create backup of meta.json
          cp meta.json meta.json.bak

          # Update meta.json for version tracking
          jq --arg version "$VERSION" \
             --arg timestamp "$TIMESTAMP" \
             --arg date "$DATE" \
             --arg major "$MAJOR" \
             --arg minor "$MINOR" \
             --arg patch "$PATCH" \
          '.docsVersion = $version |
           .channels.docs.latest = $version |
           .channels.docs.stable = $version |
           .metadata.lastUpdatedTimestamp = $timestamp |
           .releases = (.releases | map(
              if .type == "docs" and .isLatest then
                .isLatest = false
              else
                .
              end
           )) + [{
             "type": "docs",
             "version": $version,
             "date": $date,
             "timestamp": $timestamp,
             "formattedDate": $date,
             "major": $major,
             "minor": $minor,
             "patch": $patch,
             "channel": "stable",
             "path": "/v" + $major + "." + $minor + "/",
             "isLatest": true,
             "isStable": true,
             "displayOrder": 0
           }]' meta.json > meta.json.tmp && mv meta.json.tmp meta.json

          echo "::endgroup::"

      - name: "🏗️ Build Documentation"
        id: build
        run: |
          echo "::group::Documentation Build"
          # Set environment variables for build
          export VITE_APP_VERSION="${{ needs.release.outputs.version }}"
          export VITE_APP_BUILD_TIMESTAMP="$(date -u '+%Y-%m-%dT%H:%M:%SZ')"

          # Execute build
          bun run docs:build
          echo "::endgroup::"

      - name: "🔍 Verify Build Output"
        run: |
          echo "::group::Build Verification"
          if [[ ! -d "${{ env.DOCS_OUTPUT_DIR }}" ]]; then
            echo "::error::Documentation build failed, output directory not found"
            exit 1
          fi

          # Count pages
          PAGE_COUNT=$(find "${{ env.DOCS_OUTPUT_DIR }}" -name "*.html" | wc -l)
          echo "🔹 Generated $PAGE_COUNT HTML pages"
          echo "::endgroup::"

      - name: "📤 Upload Pages Artifact"
        uses: actions/upload-pages-artifact@v3
        with:
          path: ${{ env.DOCS_OUTPUT_DIR }}
          retention-days: 30

      - name: "🚀 Deploy to GitHub Pages"
        id: deployment
        if: env.DRY_RUN != 'true'
        uses: actions/deploy-pages@v4

  # ============================================================
  # Version Tags
  # ============================================================
  version-tags:
    name: "🏷️ Create Version Tags"
    needs: [release, build-deploy]
    if: needs.release.outputs.releases_created == 'true'
    runs-on: ubuntu-latest
    timeout-minutes: 3

    steps:
      - name: "⬇️ Checkout Repository"
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: "🔧 Configure Git"
        run: |
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"

      - name: "🔢 Extract Version Components"
        id: version-parts
        run: |
          IFS='.' read -r MAJOR MINOR PATCH <<< "${{ needs.release.outputs.version }}"
          echo "major=$MAJOR" >> $GITHUB_OUTPUT
          echo "minor=$MINOR" >> $GITHUB_OUTPUT
          echo "patch=$PATCH" >> $GITHUB_OUTPUT

      - name: "🏷️ Create Semantic Version Tags"
        id: create-tags
        if: env.DRY_RUN != 'true'
        run: |
          echo "::group::Tag Creation"
          # Create version tags
          MAJOR_TAG="docs/v${{ steps.version-parts.outputs.major }}"
          MINOR_TAG="docs/v${{ steps.version-parts.outputs.major }}.${{ steps.version-parts.outputs.minor }}"
          LATEST_TAG="docs/latest"

          # Create or update tags with annotations
          git tag -fa "$MAJOR_TAG" -m "Latest v${{ steps.version-parts.outputs.major }}.x documentation release"
          git tag -fa "$MINOR_TAG" -m "Latest v${{ steps.version-parts.outputs.major }}.${{ steps.version-parts.outputs.minor }}.x documentation release"
          git tag -fa "$LATEST_TAG" -m "Latest documentation release (v${{ needs.release.outputs.version }})"

          # Push tags to remote
          git push origin "$MAJOR_TAG" --force
          git push origin "$MINOR_TAG" --force
          git push origin "$LATEST_TAG" --force

          echo "tags_created=true" >> $GITHUB_OUTPUT
          echo "::endgroup::"

  # ============================================================
  # Summary
  # ============================================================
  summary:
    name: "📊 Release Summary"
    needs: [release, build-deploy, version-tags]
    if: always() && needs.release.outputs.releases_created == 'true'
    runs-on: ubuntu-latest
    timeout-minutes: 2

    steps:
      - name: "📝 Generate Summary"
        run: |
          echo "# 📚 Documentation Release Summary" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "## Release Details" >> $GITHUB_STEP_SUMMARY
          echo "- **Version:** v${{ needs.release.outputs.version }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Tag:** ${{ needs.release.outputs.tag_name }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Release URL:** ${{ needs.release.outputs.release_url || 'Not available' }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Release Mode:** ${{ env.DRY_RUN == 'true' && '🧪 Dry Run' || '🚀 Production' }}" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY

          echo "## Deployment" >> $GITHUB_STEP_SUMMARY
          if [[ "${{ env.DRY_RUN }}" == "true" ]]; then
            echo "- **URL:** 🧪 Dry run - no deployment" >> $GITHUB_STEP_SUMMARY
          else
            echo "- **URL:** [GitHub Pages](${{ needs.build-deploy.outputs.deployment_url }})" >> $GITHUB_STEP_SUMMARY
          fi
