# Documentation Release Management Workflow
name: "ğŸ“š Documentation Release Management"

# ============================================================
# ğŸš€ Workflow triggers for documentation updates
# ============================================================
on:
  # Trigger on documentation and configuration changes
  push:
    branches:
      - master                                     # Main branch for documentation
    paths:
      - 'src/docs/**'                              # Documentation source files
      - 'release-please-config.json'               # Release configuration
      - '.release-please-manifest.json'            # Version manifest
      - 'meta.json'                                # Site metadata

  # Manual workflow dispatch for immediate releases
  workflow_dispatch:
    inputs:
      dry_run:
        description: "Simulate release without publishing"
        type: boolean
        default: false
      debug:
        description: "Enable debug logging"
        type: boolean
        default: false
      create_tag:
        description: "Create a tag with custom release notes"
        type: boolean
        default: true
      deploy_docs:
        description: "Build and deploy documentation site"
        type: boolean
        default: true
      custom_release:
        description: "Create a custom release (initial v1.0.0)"
        type: boolean
        default: false
      version:
        description: "Version for custom release (e.g., 1.0.0)"
        type: string
        required: false
        default: "1.0.0"
      release_notes:
        description: "Custom release notes for initial release"
        type: string
        required: false

# ============================================================
# ğŸ”’ Prevent redundant executions
# ============================================================
concurrency:
  group: ${{ github.workflow }}-${{ github.run_id }}
  cancel-in-progress: false

# ============================================================
# ğŸ”’ Required permissions
# ============================================================
permissions:
  contents: write                                 # For releases and tags
  pull-requests: write                            # For creating PRs
  pages: write                                    # For GitHub Pages deployment
  id-token: write                                 # For Pages authentication
  issues: read                                    # For linking issues in release notes

# ============================================================
# ğŸŒ Global environment variables
# ============================================================
env:
  BUN_VERSION: "package.json"                     # Bun version from package.json
  DOCS_SOURCE_DIR: "src/docs"
  DOCS_OUTPUT_DIR: "src/docs/.vitepress/dist"
  DEBUG_MODE: ${{ github.event.inputs.debug == 'true' }}
  DRY_RUN: ${{ github.event.inputs.dry_run == 'true' }}
  CUSTOM_RELEASE: ${{ github.event.inputs.custom_release == 'true' }}
  CUSTOM_VERSION: ${{ github.event.inputs.version }}
  EXECUTION_ID: ${{ github.run_id }}-${{ github.run_attempt }}
  NODE_OPTIONS: "--max-old-space-size=4096"       # Prevents memory issues with large builds

# ============================================================
# Jobs
# ============================================================
jobs:
  # ============================================================
  # Preflight Checks
  # ============================================================
  preflight:
    name: "ğŸ” Preflight Checks"
    runs-on: ubuntu-latest
    timeout-minutes: 3
    outputs:
      proceed: ${{ steps.validation.outputs.proceed }}
      config_valid: ${{ steps.config-validation.outputs.valid }}
      is_custom_release: ${{ env.CUSTOM_RELEASE }}
      existing_release: ${{ steps.check-existing-release.outputs.exists }}

    steps:
      - name: "â¬‡ï¸ Checkout Repository"
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: "ğŸ” Log Execution Context"
        run: |
          echo "::group::Execution Context"
          echo "ğŸ”¹ Run ID: ${{ env.EXECUTION_ID }}"
          echo "ğŸ”¹ Workflow: ${{ github.workflow }}"
          echo "ğŸ”¹ Repository: ${{ github.repository }}"
          echo "ğŸ”¹ Trigger: ${{ github.event_name }}"
          echo "ğŸ”¹ Debug Mode: ${{ env.DEBUG_MODE == 'true' && 'Enabled' || 'Disabled' }}"
          echo "ğŸ”¹ Dry Run: ${{ env.DRY_RUN == 'true' && 'Enabled' || 'Disabled' }}"
          echo "ğŸ”¹ Custom Release: ${{ env.CUSTOM_RELEASE == 'true' && 'Enabled' || 'Disabled' }}"
          if [[ "${{ env.CUSTOM_RELEASE }}" == "true" ]]; then
            echo "ğŸ”¹ Custom Version: ${{ env.CUSTOM_VERSION }}"
          fi
          echo "::endgroup::"

      - name: Check Runner Version
        run: |
          if ! printf "%s\n%s" "2.323.0" "${ACTIONS_RUNNER_VERSION}" | sort -V | head -n 1 | grep -q "2.323.0"; then
            echo "::warning::Runner version ${ACTIONS_RUNNER_VERSION} is older than recommended minimum (2.323.0)"
          else
            echo "Runner version ${ACTIONS_RUNNER_VERSION} meets requirements"
          fi

      - name: "ğŸ“‘ Validate Required Files"
        id: validation
        run: |
          echo "::group::File Validation"
          # Verify required files exist
          REQUIRED_FILES=(
            "release-please-config.json"
            ".release-please-manifest.json"
            "package.json"
            "meta.json"
          )

          MISSING_FILES=()
          for file in "${REQUIRED_FILES[@]}"; do
            if [[ -f "$file" ]]; then
              echo "ğŸ”¹ Found: $file"
            else
              echo "âŒ Missing: $file"
              MISSING_FILES+=("$file")
            fi
          done

          if [[ ${#MISSING_FILES[@]} -gt 0 ]]; then
            echo "::error::Missing required files: ${MISSING_FILES[*]}"
            echo "proceed=false" >> $GITHUB_OUTPUT
            exit 1
          fi

          # Validate documentation directory
          if [[ ! -d "${{ env.DOCS_SOURCE_DIR }}" ]]; then
            echo "::error::Documentation directory not found: ${{ env.DOCS_SOURCE_DIR }}"
            echo "proceed=false" >> $GITHUB_OUTPUT
            exit 1
          fi

          echo "proceed=true" >> $GITHUB_OUTPUT
          echo "::notice::Repository file structure validation successful"
          echo "::endgroup::"

      - name: "ğŸ”„ Validate Release Configuration"
        id: config-validation
        if: steps.validation.outputs.proceed == 'true'
        run: |
          echo "::group::Configuration Validation"
          # Validate release-please config
          if jq -e '.packages.docs' release-please-config.json > /dev/null; then
            echo "ğŸ”¹ Documentation component found in release-please config"
            echo "valid=true" >> $GITHUB_OUTPUT
          else
            echo "::error::Documentation component not configured in release-please-config.json"
            echo "valid=false" >> $GITHUB_OUTPUT
            exit 1
          fi
          echo "::endgroup::"

      - name: "ğŸ” Check Existing Release"
        id: check-existing-release
        run: |
          echo "::group::Release Tags Check"

          # Check if we're doing a custom release
          if [[ "${{ env.CUSTOM_RELEASE }}" == "true" ]]; then
            # Check if the tag already exists
            if git ls-remote --tags origin | grep -q "refs/tags/v${{ env.CUSTOM_VERSION }}"; then
              echo "::warning::Tag v${{ env.CUSTOM_VERSION }} already exists"
              echo "exists=true" >> $GITHUB_OUTPUT
            else
              echo "ğŸ”¹ No existing release found for v${{ env.CUSTOM_VERSION }}"
              echo "exists=false" >> $GITHUB_OUTPUT
            fi
          else
            echo "ğŸ”¹ Not a custom release, skipping existing tag verification"
            echo "exists=false" >> $GITHUB_OUTPUT
          fi
          echo "::endgroup::"

  # ============================================================
  # Custom Release (Initial v1.0.0 Release)
  # ============================================================
  custom-release:
    name: "ğŸš€ Create Custom Release"
    needs: preflight
    if: needs.preflight.outputs.proceed == 'true' && needs.preflight.outputs.is_custom_release == 'true' && needs.preflight.outputs.existing_release == 'false' && github.event.inputs.create_tag == 'true'
    runs-on: ubuntu-latest
    timeout-minutes: 5
    outputs:
      version: ${{ env.CUSTOM_VERSION }}
      tag_name: v${{ env.CUSTOM_VERSION }}
      releases_created: true

    steps:
      - name: "â¬‡ï¸ Checkout Repository"
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: "ğŸ”§ Configure Git"
        run: |
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"

      - name: "ğŸ“ Update Manifest and Meta"
        run: |
          echo "::group::Updating Version Information"
          VERSION="${{ env.CUSTOM_VERSION }}"
          TIMESTAMP=$(date -u '+%Y-%m-%dT%H:%M:%SZ')
          DATE=$(date '+%B %d, %Y')

          # Update .release-please-manifest.json with custom version
          jq --arg version "$VERSION" '.docs = $version' .release-please-manifest.json > .release-please-manifest.json.tmp && mv .release-please-manifest.json.tmp .release-please-manifest.json
          echo "ğŸ”¹ Updated release-please-manifest.json with version: $VERSION"

          # Parse version components
          IFS='.' read -r MAJOR MINOR PATCH <<< "$VERSION"

          # Update meta.json for version tracking
          jq --arg version "$VERSION" \
             --arg timestamp "$TIMESTAMP" \
             --arg date "$DATE" \
             --arg major "$MAJOR" \
             --arg minor "$MINOR" \
             --arg patch "$PATCH" \
             '.docsVersion = $version |
              .channels.docs.latest = $version |
              .channels.docs.stable = $version |
              .metadata.lastUpdatedTimestamp = $timestamp |
              .releases = (.releases | map(
                 if .type == "docs" and .isLatest then
                   .isLatest = false
                 else
                   .
                 end
              )) + [{
                "type": "docs",
                "version": $version,
                "date": $date,
                "timestamp": $timestamp,
                "formattedDate": $date,
                "major": $major,
                "minor": $minor,
                "patch": $patch,
                "channel": "stable",
                "path": "/v" + $major + "." + $minor + "/",
                "isLatest": true,
                "isStable": true,
                "displayOrder": 0
              }]' meta.json > meta.json.tmp && mv meta.json.tmp meta.json
          echo "ğŸ”¹ Updated meta.json with version information"
          echo "::endgroup::"

      - name: "ğŸ“ Create CHANGELOG Entry"
        run: |
          echo "::group::Updating CHANGELOG"
          VERSION="${{ env.CUSTOM_VERSION }}"
          DATE=$(date '+%Y-%m-%d')
          RELEASE_NOTES="${{ github.event.inputs.release_notes }}"

          if [[ -z "$RELEASE_NOTES" ]]; then
            # Default release notes if none provided
            RELEASE_NOTES="Initial v$VERSION release of Profile Weather View documentation."
          fi

          # Create or update CHANGELOG.md
          if [[ ! -f "CHANGELOG.md" ]]; then
            # Create new changelog file with predefined content
            echo "# Changelog" > CHANGELOG.md
            echo "" >> CHANGELOG.md
            echo "## [$VERSION] - $DATE" >> CHANGELOG.md
            echo "" >> CHANGELOG.md
            echo "$RELEASE_NOTES" >> CHANGELOG.md
          else
            # Create a temporary changelog file
            cp CHANGELOG.md changelog.tmp

            # Write the new content to a temporary file
            echo "# Changelog" > new.changelog
            echo "" >> new.changelog
            echo "## [$VERSION] - $DATE" >> new.changelog
            echo "" >> new.changelog
            echo "$RELEASE_NOTES" >> new.changelog
            echo "" >> new.changelog

            # Append the rest of the existing changelog (excluding the header)
            tail -n +2 changelog.tmp >> new.changelog

            # Replace the original with the new version
            mv new.changelog CHANGELOG.md
            rm changelog.tmp
          fi

          echo "ğŸ”¹ Updated CHANGELOG.md with v$VERSION release notes"
          echo "::endgroup::"

      - name: "ğŸ·ï¸ Create Release Tag"
        if: env.DRY_RUN != 'true'
        run: |
          echo "::group::Creating Release Tag"
          VERSION="${{ env.CUSTOM_VERSION }}"
          TAG="v$VERSION"

          # Commit the version updates
          git add .release-please-manifest.json meta.json CHANGELOG.md
          git commit -m "chore(release): $TAG"

          # Create annotated tag
          git tag -a "$TAG" -m "Release v$VERSION"

          # Push changes and tag with retries
          PUSH_SUCCESS=false
          for attempt in {1..3}; do
            git push origin "${{ github.event.repository.default_branch }}" && git push origin "$TAG" && PUSH_SUCCESS=true && break || echo "Retrying push for $TAG (attempt $attempt)..."
          done

          if [ "$PUSH_SUCCESS" = false ]; then
            echo "::error::Failed to push changes and tag after 3 attempts."
            exit 1
          fi

          echo "ğŸ”¹ Successfully created and pushed tag: $TAG"
          echo "::endgroup::"

      - name: "ğŸš€ Create GitHub Release"
        if: env.DRY_RUN != 'true'
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const version = process.env.CUSTOM_VERSION;
            const releaseNotes = process.env.RELEASE_NOTES || `Initial v${version} release of Profile Weather View documentation.`;

            console.log(`Creating release for tag v${version}`);

            const release = await github.rest.repos.createRelease({
              owner: context.repo.owner,
              repo: context.repo.repo,
              tag_name: `v${version}`,
              name: `v${version}`,
              body: releaseNotes,
              draft: false,
              prerelease: false,
              generate_release_notes: false
            });

            console.log(`Release created: ${release.data.html_url}`);
        env:
          CUSTOM_VERSION: ${{ env.CUSTOM_VERSION }}
          RELEASE_NOTES: ${{ github.event.inputs.release_notes }}

  # ============================================================
  # Release Please
  # ============================================================
  release:
    name: "ğŸš€ Release Please"
    needs: preflight
    if: needs.preflight.outputs.proceed == 'true' && needs.preflight.outputs.config_valid == 'true' && needs.preflight.outputs.is_custom_release != 'true'
    runs-on: ubuntu-latest
    timeout-minutes: 5
    outputs:
      releases_created: ${{ steps.release.outputs.releases_created }}
      tag_name: ${{ steps.release.outputs.tag_name }}
      version: ${{ steps.version.outputs.version }}
      release_url: ${{ steps.release.outputs.html_url }}
      pr_url: ${{ steps.release.outputs.pr }}

    steps:
      - name: "â¬‡ï¸ Checkout Repository"
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: "ğŸ”„ Run Release Please"
        id: release
        uses: googleapis/release-please-action@v4
        env:
          DEBUG: ${{ env.DEBUG_MODE == 'true' && 'true' || '' }}
        with:
          token: ${{ secrets.GITHUB_TOKEN }}
          config-file: release-please-config.json
          manifest-file: .release-please-manifest.json
          skip-github-release: ${{ env.DRY_RUN == 'true' }}
          path: "."

      - name: "ğŸ·ï¸ Extract Version Information"
        id: version
        if: steps.release.outputs.releases_created
        run: |
          TAG="${{ steps.release.outputs.tag_name }}"
          VERSION="${TAG#*v}"  # Handle potential component prefix
          echo "version=$VERSION" >> $GITHUB_OUTPUT
          echo "::notice::New documentation release: $VERSION"

      - name: "ğŸ“Š Log Release Information"
        if: steps.release.outputs.releases_created
        run: |
          echo "::group::Release Information"
          echo "ğŸ”¹ Release Created: Yes"
          echo "ğŸ”¹ Tag Name: ${{ steps.release.outputs.tag_name }}"
          echo "ğŸ”¹ Version: ${{ steps.version.outputs.version }}"
          echo "ğŸ”¹ Release URL: ${{ steps.release.outputs.html_url }}"
          echo "::endgroup::"

  # ============================================================
  # Build and Deploy
  # ============================================================
  build-deploy:
    name: "ğŸ“š Build & Deploy Documentation"
    needs: [preflight, release, custom-release]
    if: |
      ((needs.preflight.outputs.is_custom_release == 'true' && needs.custom-release.outputs.releases_created == 'true') ||
       (needs.preflight.outputs.is_custom_release != 'true' && needs.release.outputs.releases_created == 'true')) &&
      github.event_name != 'workflow_dispatch' || github.event.inputs.deploy_docs == 'true'
    runs-on: ubuntu-latest
    timeout-minutes: 10
    outputs:
      deployment_url: ${{ steps.deployment.outputs.page_url }}

    steps:
      - name: "â¬‡ï¸ Checkout Repository"
        uses: actions/checkout@v4
        with:
          ref: ${{ needs.preflight.outputs.is_custom_release == 'true' && format('v{0}', env.CUSTOM_VERSION) || needs.release.outputs.tag_name }}
          fetch-depth: 1

      - name: "ğŸ“‹ Extract Bun Version"
        id: extract-bun-version
        run: |
          BUN_VERSION=$(node -e "const pkg = require('./package.json'); const pm = pkg.packageManager || ''; const version = pm.match(/bun@(.*)/); console.log(version ? version[1] : '1.2.9')")
          echo "BUN_VERSION=$BUN_VERSION" >> $GITHUB_ENV
          echo "::notice::Using Bun version $BUN_VERSION from package.json"

      - name: "ğŸ§° Setup Bun Runtime"
        uses: oven-sh/setup-bun@v2
        with:
          bun-version: ${{ env.BUN_VERSION }}

      - name: "ğŸ’¾ Cache Dependencies"
        uses: actions/cache@v4
        with:
          path: |
            ~/.bun/install/cache
            node_modules
          key: ${{ runner.os }}-bun-v4-${{ hashFiles('**/bun.lockb', '**/package.json') }}
          restore-keys: |
            ${{ runner.os }}-bun-v4-
          enableCrossOsArchive: false
          fail-on-cache-miss: false

      - name: "ğŸ“¦ Install Dependencies"
        run: |
          echo "::group::Dependency Installation"
          bun install --frozen-lockfile
          echo "::endgroup::"

      - name: "âš™ï¸ Configure GitHub Pages"
        uses: actions/configure-pages@v5

      - name: "ğŸ”„ Update Version Metadata"
        id: update-metadata
        run: |
          echo "::group::Metadata Update"
          VERSION="${{ needs.preflight.outputs.is_custom_release == 'true' && env.CUSTOM_VERSION || needs.release.outputs.version }}"
          TIMESTAMP=$(date -u '+%Y-%m-%dT%H:%M:%SZ')
          DATE=$(date '+%B %d, %Y')

          # Parse version components
          IFS='.' read -r MAJOR MINOR PATCH <<< "$VERSION"
          echo "ğŸ”¹ Version components: Major=$MAJOR, Minor=$MINOR, Patch=$PATCH"

          # Create backup of meta.json
          cp meta.json meta.json.bak

          # Update meta.json for version tracking
          jq --arg version "$VERSION" \
             --arg timestamp "$TIMESTAMP" \
             --arg date "$DATE" \
             --arg major "$MAJOR" \
             --arg minor "$MINOR" \
             --arg patch "$PATCH" \
          '.docsVersion = $version |
           .channels.docs.latest = $version |
           .channels.docs.stable = $version |
           .metadata.lastUpdatedTimestamp = $timestamp |
           .releases = (.releases | map(
              if .type == "docs" and .isLatest then
                .isLatest = false
              else
                .
              end
           )) + [{
             "type": "docs",
             "version": $version,
             "date": $date,
             "timestamp": $timestamp,
             "formattedDate": $date,
             "major": $major,
             "minor": $minor,
             "patch": $patch,
             "channel": "stable",
             "path": "/v" + $major + "." + $minor + "/",
             "isLatest": true,
             "isStable": true,
             "displayOrder": 0
           }]' meta.json > meta.json.tmp && mv meta.json.tmp meta.json

          echo "::endgroup::"

      - name: "ğŸ—ï¸ Build Documentation"
        id: build
        run: |
          echo "::group::Documentation Build"
          # Set environment variables for build
          export VITE_APP_VERSION="${{ needs.preflight.outputs.is_custom_release == 'true' && env.CUSTOM_VERSION || needs.release.outputs.version }}"
          export VITE_APP_BUILD_TIMESTAMP="$(date -u '+%Y-%m-%dT%H:%M:%SZ')"

          # Execute build
          bun run docs:build
          echo "::endgroup::"

      - name: "ğŸ” Verify Build Output"
        run: |
          echo "::group::Build Verification"
          if [[ ! -d "${{ env.DOCS_OUTPUT_DIR }}" ]]; then
            echo "::error::Documentation build failed, output directory not found"
            exit 1
          fi

          # Count pages
          PAGE_COUNT=$(find "${{ env.DOCS_OUTPUT_DIR }}" -name "*.html" | wc -l)
          echo "ğŸ”¹ Generated $PAGE_COUNT HTML pages"
          echo "::endgroup::"

      - name: "ğŸ“¤ Upload Pages Artifact"
        uses: actions/upload-pages-artifact@v3
        with:
          path: ${{ env.DOCS_OUTPUT_DIR }}
          retention-days: 30

      - name: "ğŸš€ Deploy to GitHub Pages"
        id: deployment
        if: env.DRY_RUN != 'true'
        uses: actions/deploy-pages@v4

  # ============================================================
  # Version Tags
  # ============================================================
  version-tags:
    name: "ğŸ·ï¸ Create Version Tags"
    needs: [preflight, release, custom-release, build-deploy]
    if: |
      (needs.preflight.outputs.is_custom_release == 'true' && needs.custom-release.outputs.releases_created == 'true') ||
      (needs.preflight.outputs.is_custom_release != 'true' && needs.release.outputs.releases_created == 'true')
    runs-on: ubuntu-latest
    timeout-minutes: 3

    steps:
      - name: "â¬‡ï¸ Checkout Repository"
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: "ğŸ”§ Configure Git"
        run: |
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"

      - name: "ğŸ”¢ Extract Version Components"
        id: version-parts
        run: |
          VERSION="${{ needs.preflight.outputs.is_custom_release == 'true' && env.CUSTOM_VERSION || needs.release.outputs.version }}"
          IFS='.' read -r MAJOR MINOR PATCH <<< "$VERSION"
          echo "major=$MAJOR" >> $GITHUB_OUTPUT
          echo "minor=$MINOR" >> $GITHUB_OUTPUT
          echo "patch=$PATCH" >> $GITHUB_OUTPUT

      - name: "ğŸ·ï¸ Create Semantic Version Tags"
        id: create-tags
        if: env.DRY_RUN != 'true'
        run: |
          echo "::group::Tag Creation"
          # Create version tags
          MAJOR_TAG="docs/v${{ steps.version-parts.outputs.major }}"
          MINOR_TAG="docs/v${{ steps.version-parts.outputs.major }}.${{ steps.version-parts.outputs.minor }}"
          LATEST_TAG="docs/latest"

          # Create or update tags with annotations
          git tag -fa "$MAJOR_TAG" -m "Latest v${{ steps.version-parts.outputs.major }}.x documentation release"
          git tag -fa "$MINOR_TAG" -m "Latest v${{ steps.version-parts.outputs.major }}.${{ steps.version-parts.outputs.minor }}.x documentation release"
          git tag -fa "$LATEST_TAG" -m "Latest documentation release (v${{ (needs.preflight.outputs.is_custom_release == 'true' && env.CUSTOM_VERSION) || needs.release.outputs.version }})"

          # Push tags to remote with retry logic
          MAJOR_PUSH_SUCCESS=false
          for attempt in {1..3}; do
            git push origin "$MAJOR_TAG" --force && MAJOR_PUSH_SUCCESS=true && break || echo "Retrying push for $MAJOR_TAG (attempt $attempt)..."
            sleep 5
          done
          if [ "$MAJOR_PUSH_SUCCESS" = false ]; then
            echo "Failed to push $MAJOR_TAG after 3 attempts."
            exit 1
          fi

          MINOR_PUSH_SUCCESS=false
          for attempt in {1..3}; do
            git push origin "$MINOR_TAG" --force && MINOR_PUSH_SUCCESS=true && break || echo "Retrying push for $MINOR_TAG (attempt $attempt)..."
            sleep 5
          done
          if [ "$MINOR_PUSH_SUCCESS" = false ]; then
            echo "Failed to push $MINOR_TAG after 3 attempts."
            exit 1
          fi

          LATEST_PUSH_SUCCESS=false
          for attempt in {1..3}; do
            git push origin "$LATEST_TAG" --force && LATEST_PUSH_SUCCESS=true && break || echo "Retrying push for $LATEST_TAG (attempt $attempt)..."
            sleep 5
          done
          if [ "$LATEST_PUSH_SUCCESS" = false ]; then
            echo "Failed to push $LATEST_TAG after 3 attempts."
            exit 1
          fi

          echo "tags_created=true" >> $GITHUB_OUTPUT
          echo "::endgroup::"

  # ============================================================
  # Summary
  # ============================================================
  summary:
    name: "ğŸ“Š Release Summary"
    needs: [preflight, release, custom-release, build-deploy, version-tags]
    if: |
      always() && (
        (needs.preflight.outputs.is_custom_release == 'true' && needs.custom-release.outputs.releases_created == 'true') ||
        (needs.preflight.outputs.is_custom_release != 'true' && needs.release.outputs.releases_created == 'true')
      )
    runs-on: ubuntu-latest
    timeout-minutes: 2

    steps:
      - name: "ğŸ“ Generate Summary"
        run: |
          echo "# ğŸ“š Documentation Release Summary" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "## Release Details" >> $GITHUB_STEP_SUMMARY

          if [[ "${{ needs.preflight.outputs.is_custom_release }}" == "true" ]]; then
            echo "- **Type:** ğŸ¯ Custom Initial Release" >> $GITHUB_STEP_SUMMARY
            echo "- **Version:** v${{ env.CUSTOM_VERSION }}" >> $GITHUB_STEP_SUMMARY
            echo "- **Tag:** v${{ env.CUSTOM_VERSION }}" >> $GITHUB_STEP_SUMMARY
          else
            echo "- **Type:** ğŸ¤– Automated Release" >> $GITHUB_STEP_SUMMARY
            echo "- **Version:** v${{ needs.release.outputs.version }}" >> $GITHUB_STEP_SUMMARY
            echo "- **Tag:** ${{ needs.release.outputs.tag_name }}" >> $GITHUB_STEP_SUMMARY
            echo "- **Release URL:** ${{ needs.release.outputs.release_url || 'Not available' }}" >> $GITHUB_STEP_SUMMARY
            echo "- **PR URL:** ${{ needs.release.outputs.pr_url || 'Not available' }}" >> $GITHUB_STEP_SUMMARY
          fi

          echo "- **Release Mode:** ${{ env.DRY_RUN == 'true' && 'ğŸ§ª Dry Run' || 'ğŸš€ Production' }}" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY

          echo "## Deployment" >> $GITHUB_STEP_SUMMARY
          if [[ "${{ env.DRY_RUN }}" == "true" ]]; then
            echo "- **URL:** ğŸ§ª Dry run - no deployment" >> $GITHUB_STEP_SUMMARY
          else
            echo "- **URL:** [GitHub Pages](${{ needs.build-deploy.outputs.deployment_url }})" >> $GITHUB_STEP_SUMMARY
          fi
