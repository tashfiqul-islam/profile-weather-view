name: "üîç Manual Dependency Check"

# ============================================================
# ‚ö° Trigger Configuration (Manual only)
# ============================================================
on:
  workflow_dispatch:
    inputs:
      package_type:
        description: "Type of package updates to check"
        type: choice
        required: true
        default: "all"
        options:
          - "all"
          - "npm"
          - "github-actions"
          - "bun-runtime"
      auto_merge:
        description: "Auto-merge eligible updates"
        type: boolean
        default: true
      only_security:
        description: "Only check for security updates"
        type: boolean
        default: false
      vulnerability_scan:
        description: "Perform vulnerability scanning"
        type: boolean
        default: true
      generate_sbom:
        description: "Generate Software Bill of Materials"
        type: boolean
        default: true
      dry_run:
        description: "Dry run (don't actually create PRs)"
        type: boolean
        default: false
      debug:
        description: "Enable debug mode"
        type: boolean
        default: false

# ============================================================
# üö´ Prevent Redundant Runs
# ============================================================
concurrency:
  group: ${{ github.workflow }}-${{ github.ref }}
  cancel-in-progress: false

# ============================================================
# üîí Permissions (Least Privilege Principle)
# ============================================================
permissions:
  contents: write  # For repository updates
  pull-requests: write  # For PR creation and management
  issues: read  # For reading repo issues
  id-token: write  # For SLSA provenance
  security-events: write  # For vulnerability reporting

# ============================================================
# üåç Environment Variables
# ============================================================
env:
  GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
  CHECK_TYPE: ${{ github.event.inputs.package_type || 'all' }}
  AUTO_MERGE: ${{ github.event.inputs.auto_merge || 'true' }}
  SECURITY_ONLY: ${{ github.event.inputs.only_security || 'false' }}
  VULN_SCAN: ${{ github.event.inputs.vulnerability_scan || 'true' }}
  GENERATE_SBOM: ${{ github.event.inputs.generate_sbom || 'true' }}
  DRY_RUN: ${{ github.event.inputs.dry_run || 'false' }}
  DEBUG: ${{ github.event.inputs.debug || 'false' }}

# ============================================================
# üîÑ Jobs
# ============================================================
jobs:
  check-dependencies:
    name: "üîç Check Dependencies"
    runs-on: ubuntu-latest
    timeout-minutes: 10

    steps:
      - name: "‚¨áÔ∏è Checkout Repository"
        uses: actions/checkout@v4
        with:
          fetch-depth: 0  # Full history for correct versioning

      - name: "üîê Verify Repository Integrity"
        run: |
          echo "::group::Verifying repository integrity"
          git verify-commit HEAD || echo "::warning::Last commit is not signed"
          echo "::endgroup::"

      - name: "üß∞ Setup Tools"
        run: |
          echo "::group::Setting up tools"
          # Install dependency update tools
          npm install -g npm-check-updates@latest
          sudo apt-get update && sudo apt-get install -y jq curl

          # Install SBOM tools
          if [ "${{ env.GENERATE_SBOM }}" == "true" ]; then
            echo "Installing SBOM tools..."
            npm install -g @cyclonedx/cdxgen
          fi

          # Install vulnerability scanning tools
          if [ "${{ env.VULN_SCAN }}" == "true" ]; then
            echo "Installing vulnerability scanning tools..."
            npm install -g audit-ci
          fi
          echo "::endgroup::"

      - name: "üîç Analyze Dependency Configuration"
        id: analyze-config
        run: |
          echo "::group::Analyzing dependencies"
          echo "üîπ Checking for Dependabot config"
          if [ -f ".github/dependabot.yml" ]; then
            echo "‚úÖ Dependabot configuration found"
            DEPENDABOT_CONFIG_EXISTS="true"
          else
            echo "‚ö†Ô∏è No Dependabot configuration found"
            DEPENDABOT_CONFIG_EXISTS="false"
          fi
          echo "dependabot_config_exists=$DEPENDABOT_CONFIG_EXISTS" >> $GITHUB_OUTPUT

          echo "üîπ Reading package.json"
          if [ -f "package.json" ]; then
            echo "‚úÖ package.json found"
            PACKAGE_JSON_EXISTS="true"

            # Count dependencies
            DEPS_COUNT=$(jq '.dependencies | length' package.json)
            DEV_DEPS_COUNT=$(jq '.devDependencies | length' package.json)
            echo "üìä Found $DEPS_COUNT production dependencies and $DEV_DEPS_COUNT dev dependencies"

            # Check if bun is used
            if jq -e '.packageManager | startswith("bun@")' package.json > /dev/null; then
              echo "‚úÖ Bun detected as package manager"
              BUN_VERSION=$(jq -r '.packageManager' package.json | sed 's/bun@//')
              echo "üìä Bun version: $BUN_VERSION"
              echo "bun_version=$BUN_VERSION" >> $GITHUB_OUTPUT
              echo "uses_bun=true" >> $GITHUB_OUTPUT
            else
              echo "‚ö†Ô∏è Bun not detected as package manager"
              echo "uses_bun=false" >> $GITHUB_OUTPUT
            fi
          else
            echo "‚ö†Ô∏è package.json not found"
            PACKAGE_JSON_EXISTS="false"
            echo "uses_bun=false" >> $GITHUB_OUTPUT
          fi
          echo "package_json_exists=$PACKAGE_JSON_EXISTS" >> $GITHUB_OUTPUT

          # Count GitHub Action workflows
          WORKFLOW_COUNT=$(ls -1 .github/workflows/*.yml 2>/dev/null | wc -l)
          echo "üìä Found $WORKFLOW_COUNT GitHub Action workflow files"

          echo "::endgroup::"

      - name: "üìã Generate SBOM (Software Bill of Materials)"
        if: env.GENERATE_SBOM == 'true' && steps.analyze-config.outputs.package_json_exists == 'true'
        id: generate-sbom
        run: |
          echo "::group::Generating SBOM"
          # Generate CycloneDX SBOM
          npx @cyclonedx/cdxgen -o sbom.json

          # Store SBOM format
          echo "sbom_generated=true" >> $GITHUB_OUTPUT
          echo "sbom_format=CycloneDX" >> $GITHUB_OUTPUT

          # Count components for summary
          COMPONENT_COUNT=$(jq '.components | length' sbom.json)
          echo "sbom_component_count=$COMPONENT_COUNT" >> $GITHUB_OUTPUT
          echo "üìä SBOM contains $COMPONENT_COUNT components"
          echo "::endgroup::"

      - name: "üîí Scan for Vulnerabilities"
        if: env.VULN_SCAN == 'true' && steps.analyze-config.outputs.package_json_exists == 'true'
        id: vuln-scan
        run: |
          echo "::group::Scanning for vulnerabilities"
          # Run vulnerability scan
          npx audit-ci --config audit-ci.json || echo "audit-ci.json not found, using default settings"
          SCAN_EXIT=$?

          if [ $SCAN_EXIT -eq 0 ]; then
            echo "‚úÖ No vulnerabilities found"
            echo "vulnerabilities_found=false" >> $GITHUB_OUTPUT
          else
            echo "‚ö†Ô∏è Vulnerabilities detected"
            echo "vulnerabilities_found=true" >> $GITHUB_OUTPUT

            # Count vulnerabilities by severity
            HIGH_COUNT=$(npm audit --json | jq '[.vulnerabilities[] | select(.severity=="high")] | length')
            CRITICAL_COUNT=$(npm audit --json | jq '[.vulnerabilities[] | select(.severity=="critical")] | length')

            echo "high_vulns=$HIGH_COUNT" >> $GITHUB_OUTPUT
            echo "critical_vulns=$CRITICAL_COUNT" >> $GITHUB_OUTPUT
            echo "üìä Found $HIGH_COUNT high and $CRITICAL_COUNT critical vulnerabilities"
          fi
          echo "::endgroup::"

      - name: "üîç Check npm Dependencies"
        id: check-npm
        if: env.CHECK_TYPE == 'all' || env.CHECK_TYPE == 'npm'
        run: |
          echo "::group::Checking npm dependencies"
          if [ -f "package.json" ]; then
            # Use npm-check-updates to identify available updates
            echo "üîπ Scanning for available updates..."

            # Add error handling and ensure output is valid JSON
            if [ "${{ env.SECURITY_ONLY }}" == "true" ]; then
              # For security updates only, use the target newest option
              NCU_OUTPUT=$(npx npm-check-updates --jsonUpgraded --target newest --loglevel error 2>/dev/null || echo "{}")
              UPDATE_COUNT=$(echo $NCU_OUTPUT | jq 'length')
              echo "üîπ Found $UPDATE_COUNT security-related package updates"
            else
              # For all updates, use simpler options that are known to work
              NCU_OUTPUT=$(npx npm-check-updates --jsonUpgraded --loglevel error 2>/dev/null || echo "{}")
              UPDATE_COUNT=$(echo $NCU_OUTPUT | jq 'length')
              echo "üîπ Found $UPDATE_COUNT package updates available"
            fi

            # Save the list of updates for later (only if valid)
            echo "$NCU_OUTPUT" > npm-updates.json

            if [ "$UPDATE_COUNT" -gt 0 ]; then
              echo "updates_available=true" >> $GITHUB_OUTPUT
              echo "update_count=$UPDATE_COUNT" >> $GITHUB_OUTPUT

              # Extract some example updates for the summary with better error handling
              EXAMPLES=$(echo $NCU_OUTPUT | jq -r 'to_entries | sort_by(.value) | head -3 | map("\(.key): \(.value)") | join(", ")' || echo "Details not available")
              echo "update_examples=$EXAMPLES" >> $GITHUB_OUTPUT

              echo "‚úÖ Updates available! Examples: $EXAMPLES"
            else
              echo "updates_available=false" >> $GITHUB_OUTPUT
              echo "update_count=0" >> $GITHUB_OUTPUT
              echo "‚ö†Ô∏è No npm dependency updates available"
            fi
          else
            echo "‚ö†Ô∏è No package.json found, skipping npm dependency check"
            echo "updates_available=false" >> $GITHUB_OUTPUT
            echo "update_count=0" >> $GITHUB_OUTPUT
          fi
          echo "::endgroup::"

      - name: "üîç Check Bun Runtime"
        id: check-bun
        if: (env.CHECK_TYPE == 'all' || env.CHECK_TYPE == 'bun-runtime') && steps.analyze-config.outputs.uses_bun == 'true'
        run: |
          echo "::group::Checking Bun runtime"
          # Get current Bun version from package.json
          CURRENT_BUN_VERSION="${{ steps.analyze-config.outputs.bun_version }}"
          echo "üîπ Current Bun version: $CURRENT_BUN_VERSION"

          # Check latest Bun version from API
          echo "üîπ Checking latest Bun version..."
          LATEST_BUN_VERSION=$(curl -s https://api.github.com/repos/oven-sh/bun/releases/latest | jq -r '.tag_name' | sed 's/bun-v//')
          echo "üîπ Latest Bun version: $LATEST_BUN_VERSION"

          # Compare versions
          if [ "$CURRENT_BUN_VERSION" != "$LATEST_BUN_VERSION" ]; then
            echo "bun_update_available=true" >> $GITHUB_OUTPUT
            echo "bun_current_version=$CURRENT_BUN_VERSION" >> $GITHUB_OUTPUT
            echo "bun_latest_version=$LATEST_BUN_VERSION" >> $GITHUB_OUTPUT

            # Check if this is a major, minor, or patch update
            IFS='.' read -r -a CURRENT_PARTS <<< "$CURRENT_BUN_VERSION"
            IFS='.' read -r -a LATEST_PARTS <<< "$LATEST_BUN_VERSION"

            if [ "${LATEST_PARTS[0]}" -gt "${CURRENT_PARTS[0]}" ]; then
              echo "bun_update_type=major" >> $GITHUB_OUTPUT
              echo "‚úÖ Major Bun update available: $CURRENT_BUN_VERSION -> $LATEST_BUN_VERSION"
            elif [ "${LATEST_PARTS[1]}" -gt "${CURRENT_PARTS[1]}" ]; then
              echo "bun_update_type=minor" >> $GITHUB_OUTPUT
              echo "‚úÖ Minor Bun update available: $CURRENT_BUN_VERSION -> $LATEST_BUN_VERSION"
            else
              echo "bun_update_type=patch" >> $GITHUB_OUTPUT
              echo "‚úÖ Patch Bun update available: $CURRENT_BUN_VERSION -> $LATEST_BUN_VERSION"
            fi
          else
            echo "bun_update_available=false" >> $GITHUB_OUTPUT
            echo "‚ö†Ô∏è Bun is already at the latest version ($CURRENT_BUN_VERSION)"
          fi
          echo "::endgroup::"

      - name: "üîç Check GitHub Actions"
        id: check-actions
        if: env.CHECK_TYPE == 'all' || env.CHECK_TYPE == 'github-actions'
        run: |
          echo "::group::Checking GitHub Actions"
          ACTION_UPDATES_AVAILABLE=false
          ACTION_UPDATE_COUNT=0

          # Function to check a single workflow file for outdated actions
          check_workflow_file() {
            local file="$1"
            echo "üîπ Checking $file..."

            # Extract all GitHub Actions uses statements
            ACTIONS=$(grep -o "uses: [a-zA-Z0-9_\-\.\/]*@[a-zA-Z0-9_\-\.]\\+" "$file" || echo "")

            if [ -z "$ACTIONS" ]; then
              echo "  No actions found in $file"
              return 0
            fi

            # Check each action
            while IFS= read -r ACTION; do
              # Extract name and version
              ACTION_NAME=$(echo "$ACTION" | cut -d '@' -f 1 | sed 's/uses: //')
              ACTION_VERSION=$(echo "$ACTION" | cut -d '@' -f 2)

              # Skip if version is not a tag/version (e.g., using branch name)
              if [[ ! "$ACTION_VERSION" =~ ^v[0-9]+(\.[0-9]+)*$ ]]; then
                echo "  Skipping $ACTION_NAME@$ACTION_VERSION (not a versioned tag)"
                continue
              fi

              echo "  Checking $ACTION_NAME@$ACTION_VERSION..."

              # Add verification of GitHub Action publisher
              PUBLISHER=""
              if [[ "$ACTION_NAME" =~ ^github/ ]]; then
                PUBLISHER="github"
              elif [[ "$ACTION_NAME" =~ ^oven-sh/ ]]; then
                PUBLISHER="oven-sh"
              fi

              # If trusted publisher, continue with version check
              if [ -n "$PUBLISHER" ]; then
                echo "  ‚úÖ Trusted publisher: $PUBLISHER"
              else
                echo "  ‚ö†Ô∏è Publisher verification: Unknown publisher $ACTION_NAME"
              fi

              # Get latest release through GitHub API
              if [[ "$ACTION_NAME" =~ ^[a-zA-Z0-9_\-]+/[a-zA-Z0-9_\-]+$ ]]; then
                # Handle standard GitHub repo format (owner/repo)
                LATEST_VERSION=$(curl -s -H "Accept: application/vnd.github.v3+json" \
                  https://api.github.com/repos/$ACTION_NAME/releases/latest | \
                  jq -r '.tag_name // "not_found"' 2>/dev/null || echo "not_found")
              else
                # Handle other formats (might be GitHub Marketplace actions)
                LATEST_VERSION="unknown"
              fi

              if [ "$LATEST_VERSION" != "not_found" ] && [ "$LATEST_VERSION" != "unknown" ] && [ "$LATEST_VERSION" != "$ACTION_VERSION" ]; then
                echo "  ‚úÖ Update available: $ACTION_NAME@$ACTION_VERSION -> $LATEST_VERSION"
                ACTION_UPDATES_AVAILABLE=true
                ACTION_UPDATE_COUNT=$((ACTION_UPDATE_COUNT + 1))

                # Save update info to file for later processing
                echo "$ACTION_NAME,$ACTION_VERSION,$LATEST_VERSION,$file,$PUBLISHER" >> action_updates.csv
              fi
            done <<< "$ACTIONS"
          }

          # Create output file
          touch action_updates.csv

          # Check all workflow files
          for FILE in .github/workflows/*.yml; do
            [ -f "$FILE" ] && check_workflow_file "$FILE"
          done

          # Set outputs
          echo "actions_update_available=$ACTION_UPDATES_AVAILABLE" >> $GITHUB_OUTPUT
          echo "actions_update_count=$ACTION_UPDATE_COUNT" >> $GITHUB_OUTPUT

          if [ "$ACTION_UPDATES_AVAILABLE" = true ]; then
            echo "‚úÖ Found $ACTION_UPDATE_COUNT GitHub Action updates available"

            # Get some examples for the summary
            if [ -f "action_updates.csv" ] && [ -s "action_updates.csv" ]; then
              EXAMPLES=$(head -3 action_updates.csv | awk -F, '{print $1 "@" $2 " -> " $3}' | paste -sd ", " -)
              echo "actions_update_examples=$EXAMPLES" >> $GITHUB_OUTPUT
            fi
          else
            echo "‚ö†Ô∏è No GitHub Action updates available"
          fi
          echo "::endgroup::"

      - name: "üìä Generate Results Summary"
        id: summary
        run: |
          echo "::group::Generating summary"

          # Determine if any updates are available
          NPM_UPDATES="${{ steps.check-npm.outputs.updates_available || 'false' }}"
          BUN_UPDATES="${{ steps.check-bun.outputs.bun_update_available || 'false' }}"
          ACTION_UPDATES="${{ steps.check-actions.outputs.actions_update_available || 'false' }}"
          VULNERABILITIES="${{ steps.vuln-scan.outputs.vulnerabilities_found || 'false' }}"

          if [ "$NPM_UPDATES" = "true" ] || [ "$BUN_UPDATES" = "true" ] || [ "$ACTION_UPDATES" = "true" ]; then
            echo "any_updates_available=true" >> $GITHUB_OUTPUT
            echo "‚úÖ Updates available!"
          else
            echo "any_updates_available=false" >> $GITHUB_OUTPUT
            echo "‚ö†Ô∏è No updates available"
          fi

          # Create a detailed summary
          {
            echo "# üìä Dependency Update Summary"
            echo ""

            # Add security summary first
            if [ "${{ env.VULN_SCAN }}" = "true" ]; then
              echo "## üîí Security Status"
              if [ "$VULNERABILITIES" = "true" ]; then
                echo "- ‚ö†Ô∏è **Vulnerabilities detected**: ${{ steps.vuln-scan.outputs.high_vulns }} high, ${{ steps.vuln-scan.outputs.critical_vulns }} critical"
                echo "- üö® **Action required**: Update dependencies to resolve security issues"
              else
                echo "- ‚úÖ **No vulnerabilities detected**"
              fi
              echo ""
            fi

            # Add SBOM information
            if [ "${{ env.GENERATE_SBOM }}" = "true" ] && [ "${{ steps.generate-sbom.outputs.sbom_generated }}" = "true" ]; then
              echo "## üìã Software Bill of Materials"
              echo "- ‚úÖ **SBOM generated**: ${{ steps.generate-sbom.outputs.sbom_format }} format"
              echo "- üìä **Components**: ${{ steps.generate-sbom.outputs.sbom_component_count }} tracked dependencies"
              echo ""
            fi

            echo "## üîç Scan Results"
            echo ""

            if [ "$NPM_UPDATES" = "true" ]; then
              echo "### üì¶ NPM Packages"
              echo "- ‚úÖ **${steps.check-npm.outputs.update_count}** package updates available"
              echo "- Examples: ${steps.check-npm.outputs.update_examples}"
              echo ""
            else
              echo "### üì¶ NPM Packages"
              echo "- ‚ö†Ô∏è No updates available"
              echo ""
            fi

            if [ "${{ steps.analyze-config.outputs.uses_bun }}" = "true" ]; then
              echo "### üèÉ Bun Runtime"
              if [ "$BUN_UPDATES" = "true" ]; then
                echo "- ‚úÖ **${steps.check-bun.outputs.bun_update_type}** update available: ${steps.check-bun.outputs.bun_current_version} ‚Üí ${steps.check-bun.outputs.bun_latest_version}"
              else
                echo "- ‚ö†Ô∏è Already at latest version (${steps.analyze-config.outputs.bun_version})"
              fi
              echo ""
            fi

            echo "### üîÑ GitHub Actions"
            if [ "$ACTION_UPDATES" = "true" ]; then
              echo "- ‚úÖ **${steps.check-actions.outputs.actions_update_count}** action updates available"
              if [ -n "${steps.check-actions.outputs.actions_update_examples}" ]; then
                echo "- Examples: ${steps.check-actions.outputs.actions_update_examples}"
              fi
            else
              echo "- ‚ö†Ô∏è No updates available"
            fi
            echo ""

            if [ "${{ env.DRY_RUN }}" = "true" ]; then
              echo "## ‚ÑπÔ∏è Dry Run Mode"
              echo "No actual updates will be applied. This is just a scan."
            else
              if [ "$NPM_UPDATES" = "true" ] || [ "$BUN_UPDATES" = "true" ] || [ "$ACTION_UPDATES" = "true" ] || [ "$VULNERABILITIES" = "true" ]; then
                echo "## üöÄ Next Steps"
                if [ "$VULNERABILITIES" = "true" ]; then
                  echo "**Security vulnerabilities detected!** Dependabot will be triggered to create security update PRs."
                  echo ""
                }
                echo "Dependabot will be triggered to create PRs for these updates."
              else
                echo "## ‚ÑπÔ∏è No Updates Required"
                echo "All dependencies are already up to date."
              fi
            fi
          } > dependency_summary.md

          echo "::endgroup::"

      - name: "üì§ Upload Summary Artifact"
        uses: actions/upload-artifact@v4
        with:
          name: dependency-scan-summary
          path: |
            dependency_summary.md
            sbom.json
          retention-days: 7

      - name: "üìÉ Output Summary to Steps"
        run: cat dependency_summary.md >> $GITHUB_STEP_SUMMARY

      # Add SARIF vulnerability report
      - name: "üö® Upload Vulnerability Report"
        if: env.VULN_SCAN == 'true' && steps.vuln-scan.outputs.vulnerabilities_found == 'true'
        uses: github/codeql-action/upload-sarif@v3
        with:
          sarif_file: npm-audit.sarif
          category: dependency-check

      - name: "üöÄ Trigger Dependabot"
        if: steps.summary.outputs.any_updates_available == 'true' && env.DRY_RUN != 'true'
        run: |
          echo "::group::Triggering Dependabot"

          # Check if Dependabot is configured
          if [ "${{ steps.analyze-config.outputs.dependabot_config_exists }}" != "true" ]; then
            echo "‚ö†Ô∏è Cannot trigger Dependabot - No dependabot.yml configuration found"
            echo "::endgroup::"
            exit 0
          fi

          # Prepare API data
          if [ "${{ env.CHECK_TYPE }}" = "all" ]; then
            ECOSYSTEMS="npm,github-actions"
          elif [ "${{ env.CHECK_TYPE }}" = "npm" ]; then
            ECOSYSTEMS="npm"
          elif [ "${{ env.CHECK_TYPE }}" = "github-actions" ]; then
            ECOSYSTEMS="github-actions"
          elif [ "${{ env.CHECK_TYPE }}" = "bun-runtime" ]; then
            ECOSYSTEMS="npm"  # Bun updates come through npm ecosystem
          fi

          # Prioritize security updates
          if [ "${{ steps.vuln-scan.outputs.vulnerabilities_found }}" == "true" ]; then
            echo "üîí Prioritizing security updates due to vulnerabilities detected"
            SECURITY_PARAM=",\"security-updates-only\":true"
          else
            SECURITY_PARAM=""
          fi

          echo "üîπ Triggering dependency update check for: $ECOSYSTEMS"

          # GitHub API call to trigger Dependabot with latest parameters
          curl -X POST \
            -H "Accept: application/vnd.github.v3+json" \
            -H "Authorization: token ${{ secrets.GITHUB_TOKEN }}" \
            https://api.github.com/repos/${{ github.repository }}/dependabot/scans \
            -d '{"dependency-names":[],"directory":"/","package-ecosystem":"'"$ECOSYSTEMS"'"'"$SECURITY_PARAM"'}'

          echo "::endgroup::"

          echo "‚úÖ Dependabot update scan triggered successfully!"

      - name: "üì£ Notify No Updates Available"
        if: steps.summary.outputs.any_updates_available != 'true' && env.DRY_RUN != 'true'
        run: |
          echo "::notice title=All dependencies up to date::No dependency updates are currently available. Everything is already on the latest version."
