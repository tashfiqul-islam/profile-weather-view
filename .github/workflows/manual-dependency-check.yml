name: "üîç Manual Dependency Check"

# ============================================================
# ‚ö° Trigger Configuration (Manual only)
# ============================================================
on:
  workflow_dispatch:
    inputs:
      package_type:
        description: "Type of package updates to check"
        type: choice
        required: true
        default: "all"
        options:
          - "all"
          - "npm"
          - "github-actions"
          - "bun-runtime"
      auto_merge:
        description: "Auto-merge eligible updates"
        type: boolean
        default: true
      only_security:
        description: "Only check for security updates"
        type: boolean
        default: false
      vulnerability_scan:
        description: "Perform vulnerability scanning"
        type: boolean
        default: true
      generate_sbom:
        description: "Generate Software Bill of Materials"
        type: boolean
        default: true
      dry_run:
        description: "Dry run (don't actually create PRs)"
        type: boolean
        default: false
      debug:
        description: "Enable debug mode"
        type: boolean
        default: false

# ============================================================
# üö´ Prevent Redundant Runs
# ============================================================
concurrency:
  group: ${{ github.workflow }}-${{ github.ref }}
  cancel-in-progress: false

# ============================================================
# üîí Permissions (Least Privilege Principle)
# ============================================================
permissions:
  contents: write  # For repository updates
  pull-requests: write  # For PR creation and management
  issues: read  # For reading repo issues
  id-token: write  # For SLSA provenance
  security-events: write  # For vulnerability reporting

# ============================================================
# üåç Environment Variables
# ============================================================
env:
  GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
  CHECK_TYPE: ${{ github.event.inputs.package_type || 'all' }}
  AUTO_MERGE: ${{ github.event.inputs.auto_merge || 'true' }}
  SECURITY_ONLY: ${{ github.event.inputs.only_security || 'false' }}
  VULN_SCAN: ${{ github.event.inputs.vulnerability_scan || 'true' }}
  GENERATE_SBOM: ${{ github.event.inputs.generate_sbom || 'true' }}
  DRY_RUN: ${{ github.event.inputs.dry_run || 'false' }}
  DEBUG: ${{ github.event.inputs.debug || 'false' }}

# ============================================================
# üîÑ Jobs
# ============================================================
jobs:
  check-dependencies:
    name: "üîç Check Dependencies"
    runs-on: ubuntu-latest
    timeout-minutes: 10

    steps:
      - name: "‚¨áÔ∏è Checkout Repository"
        uses: actions/checkout@v4
        with:
          fetch-depth: 0  # Full history for correct versioning

      - name: "üîê Verify Repository Integrity"
        run: |
          echo "::group::Verifying repository integrity"
          git verify-commit HEAD || echo "::warning::Last commit is not signed"
          echo "::endgroup::"

      - name: "üß∞ Setup Tools"
        run: |
          echo "::group::Setting up tools"
          # Install dependency update tools
          npm install -g npm-check-updates@latest
          sudo apt-get update && sudo apt-get install -y jq curl

          # Install SBOM tools
          if [ "${{ env.GENERATE_SBOM }}" == "true" ]; then
            echo "Installing SBOM tools..."
            npm install -g @cyclonedx/cdxgen
          fi

          # Install vulnerability scanning tools
          if [ "${{ env.VULN_SCAN }}" == "true" ]; then
            echo "Installing vulnerability scanning tools..."
            npm install -g audit-ci
          fi
          echo "::endgroup::"

      - name: "üîç Analyze Dependency Configuration"
        id: analyze-config
        run: |
          echo "::group::Analyzing dependencies"
          echo "üîπ Checking for Dependabot config"
          if [ -f ".github/dependabot.yml" ]; then
            echo "‚úÖ Dependabot configuration found"
            DEPENDABOT_CONFIG_EXISTS="true"
          else
            echo "‚ö†Ô∏è No Dependabot configuration found"
            DEPENDABOT_CONFIG_EXISTS="false"
          fi
          echo "dependabot_config_exists=$DEPENDABOT_CONFIG_EXISTS" >> $GITHUB_OUTPUT

          echo "üîπ Reading package.json"
          if [ -f "package.json" ]; then
            echo "‚úÖ package.json found"
            PACKAGE_JSON_EXISTS="true"

            # Count dependencies
            DEPS_COUNT=$(jq '.dependencies | length' package.json)
            DEV_DEPS_COUNT=$(jq '.devDependencies | length' package.json)
            echo "üìä Found $DEPS_COUNT production dependencies and $DEV_DEPS_COUNT dev dependencies"

            # Check if bun is used
            if jq -e '.packageManager | startswith("bun@")' package.json > /dev/null; then
              echo "‚úÖ Bun detected as package manager"
              BUN_VERSION=$(jq -r '.packageManager' package.json | sed 's/bun@//')
              echo "üìä Bun version: $BUN_VERSION"
              echo "bun_version=$BUN_VERSION" >> $GITHUB_OUTPUT
              echo "uses_bun=true" >> $GITHUB_OUTPUT
            else
              echo "‚ö†Ô∏è Bun not detected as package manager"
              echo "uses_bun=false" >> $GITHUB_OUTPUT
            fi
          else
            echo "‚ö†Ô∏è package.json not found"
            PACKAGE_JSON_EXISTS="false"
            echo "uses_bun=false" >> $GITHUB_OUTPUT
          fi
          echo "package_json_exists=$PACKAGE_JSON_EXISTS" >> $GITHUB_OUTPUT

          # Count GitHub Action workflows
          WORKFLOW_COUNT=$(ls -1 .github/workflows/*.yml 2>/dev/null | wc -l)
          echo "üìä Found $WORKFLOW_COUNT GitHub Action workflow files"

          echo "::endgroup::"

      - name: "üìã Generate SBOM (Software Bill of Materials)"
        if: env.GENERATE_SBOM == 'true' && steps.analyze-config.outputs.package_json_exists == 'true'
        id: generate-sbom
        run: |
          echo "::group::Generating SBOM"
          # Generate CycloneDX SBOM
          npx @cyclonedx/cdxgen -o sbom.json

          # Store SBOM format
          echo "sbom_generated=true" >> $GITHUB_OUTPUT
          echo "sbom_format=CycloneDX" >> $GITHUB_OUTPUT

          # Count components for summary
          COMPONENT_COUNT=$(jq '.components | length' sbom.json)
          echo "sbom_component_count=$COMPONENT_COUNT" >> $GITHUB_OUTPUT
          echo "üìä SBOM contains $COMPONENT_COUNT components"
          echo "::endgroup::"

      - name: "üîí Scan for Vulnerabilities"
        if: env.VULN_SCAN == 'true' && steps.analyze-config.outputs.package_json_exists == 'true'
        id: vuln-scan
        run: |
          echo "::group::Scanning for vulnerabilities"
          # Run vulnerability scan
          npx audit-ci --config audit-ci.json || echo "audit-ci.json not found, using default settings"
          SCAN_EXIT=$?

          if [ $SCAN_EXIT -eq 0 ]; then
            echo "‚úÖ No vulnerabilities found"
            echo "vulnerabilities_found=false" >> $GITHUB_OUTPUT
          else
            echo "‚ö†Ô∏è Vulnerabilities detected"
            echo "vulnerabilities_found=true" >> $GITHUB_OUTPUT

            # Count vulnerabilities by severity
            HIGH_COUNT=$(npm audit --json | jq '[.vulnerabilities[] | select(.severity=="high")] | length')
            CRITICAL_COUNT=$(npm audit --json | jq '[.vulnerabilities[] | select(.severity=="critical")] | length')

            echo "high_vulns=$HIGH_COUNT" >> $GITHUB_OUTPUT
            echo "critical_vulns=$CRITICAL_COUNT" >> $GITHUB_OUTPUT
            echo "üìä Found $HIGH_COUNT high and $CRITICAL_COUNT critical vulnerabilities"
          fi
          echo "::endgroup::"

      - name: "üîç Check npm Dependencies"
        id: check-npm
        if: env.CHECK_TYPE == 'all' || env.CHECK_TYPE == 'npm'
        run: |
          echo "::group::Checking npm dependencies"
          if [ -f "package.json" ]; then
            # Use npm-check-updates to identify available updates
            echo "üîπ Scanning for available updates..."

            # Add error handling and ensure output is valid JSON
            if [ "${{ env.SECURITY_ONLY }}" == "true" ]; then
              # For security updates only, use the target newest option
              NCU_OUTPUT=$(npx npm-check-updates --jsonUpgraded --target newest --loglevel error 2>/dev/null || echo "{}")
              UPDATE_COUNT=$(echo $NCU_OUTPUT | jq 'length')
              echo "üîπ Found $UPDATE_COUNT security-related package updates"
            else
              # For all updates, use simpler options that are known to work
              NCU_OUTPUT=$(npx npm-check-updates --jsonUpgraded --loglevel error 2>/dev/null || echo "{}")
              UPDATE_COUNT=$(echo $NCU_OUTPUT | jq 'length')
              echo "üîπ Found $UPDATE_COUNT package updates available"
            fi

            # Save the list of updates for later (only if valid)
            echo "$NCU_OUTPUT" > npm-updates.json

            if [ "$UPDATE_COUNT" -gt 0 ]; then
              echo "updates_available=true" >> $GITHUB_OUTPUT
              echo "update_count=$UPDATE_COUNT" >> $GITHUB_OUTPUT

              # Extract some example updates for the summary with better error handling
              EXAMPLES=$(echo $NCU_OUTPUT | jq -r 'to_entries | sort_by(.value) | head -3 | map("\(.key): \(.value)") | join(", ")' || echo "Details not available")
              echo "update_examples=$EXAMPLES" >> $GITHUB_OUTPUT

              echo "‚úÖ Updates available! Examples: $EXAMPLES"
            else
              echo "updates_available=false" >> $GITHUB_OUTPUT
              echo "update_count=0" >> $GITHUB_OUTPUT
              echo "‚ö†Ô∏è No npm dependency updates available"
            fi
          else
            echo "‚ö†Ô∏è No package.json found, skipping npm dependency check"
            echo "updates_available=false" >> $GITHUB_OUTPUT
            echo "update_count=0" >> $GITHUB_OUTPUT
          fi
          echo "::endgroup::"

      - name: "üîç Check Bun Runtime"
        id: check-bun
        if: (env.CHECK_TYPE == 'all' || env.CHECK_TYPE == 'bun-runtime') && steps.analyze-config.outputs.uses_bun == 'true'
        run: |
          echo "::group::Checking Bun runtime"
          # Get current Bun version from package.json
          CURRENT_BUN_VERSION="${{ steps.analyze-config.outputs.bun_version }}"
          echo "üîπ Current Bun version: $CURRENT_BUN_VERSION"

          # Check latest Bun version from API
          echo "üîπ Checking latest Bun version..."
          LATEST_BUN_VERSION=$(curl -s https://api.github.com/repos/oven-sh/bun/releases/latest | jq -r '.tag_name' | sed 's/bun-v//')
          echo "üîπ Latest Bun version: $LATEST_BUN_VERSION"

          # Compare versions
          if [ "$CURRENT_BUN_VERSION" != "$LATEST_BUN_VERSION" ]; then
            echo "bun_update_available=true" >> $GITHUB_OUTPUT
            echo "bun_current_version=$CURRENT_BUN_VERSION" >> $GITHUB_OUTPUT
            echo "bun_latest_version=$LATEST_BUN_VERSION" >> $GITHUB_OUTPUT

            # Check if this is a major, minor, or patch update
            IFS='.' read -r -a CURRENT_PARTS <<< "$CURRENT_BUN_VERSION"
            IFS='.' read -r -a LATEST_PARTS <<< "$LATEST_BUN_VERSION"

            if [ "${LATEST_PARTS[0]}" -gt "${CURRENT_PARTS[0]}" ]; then
              echo "bun_update_type=major" >> $GITHUB_OUTPUT
              echo "‚úÖ Major Bun update available: $CURRENT_BUN_VERSION -> $LATEST_BUN_VERSION"
            elif [ "${LATEST_PARTS[1]}" -gt "${CURRENT_PARTS[1]}" ]; then
              echo "bun_update_type=minor" >> $GITHUB_OUTPUT
              echo "‚úÖ Minor Bun update available: $CURRENT_BUN_VERSION -> $LATEST_BUN_VERSION"
            else
              echo "bun_update_type=patch" >> $GITHUB_OUTPUT
              echo "‚úÖ Patch Bun update available: $CURRENT_BUN_VERSION -> $LATEST_BUN_VERSION"
            fi
          else
            echo "bun_update_available=false" >> $GITHUB_OUTPUT
            echo "‚ö†Ô∏è Bun is already at the latest version ($CURRENT_BUN_VERSION)"
          fi
          echo "::endgroup::"

      - name: "üîç Check GitHub Actions"
        id: check-actions
        if: env.CHECK_TYPE == 'all' || env.CHECK_TYPE == 'github-actions'
        run: |
          echo "::group::Checking GitHub Actions"
          ACTION_UPDATES_AVAILABLE=false
          ACTION_UPDATE_COUNT=0

          # Function to check a single workflow file for outdated actions
          check_workflow_file() {
            local file="$1"
            echo "üîπ Checking $file..."

            # Extract all GitHub Actions uses statements
            ACTIONS=$(grep -o "uses: [a-zA-Z0-9_\-\.\/]*@[a-zA-Z0-9_\-\.]\\+" "$file" || echo "")

            if [ -z "$ACTIONS" ]; then
              echo "  No actions found in $file"
              return 0
            fi

            # Check each action
            while IFS= read -r ACTION; do
              # Extract name and version
              ACTION_NAME=$(echo "$ACTION" | cut -d '@' -f 1 | sed 's/uses: //')
              ACTION_VERSION=$(echo "$ACTION" | cut -d '@' -f 2)

              # Skip if version is not a tag/version (e.g., using branch name)
              if [[ ! "$ACTION_VERSION" =~ ^v[0-9]+(\.[0-9]+)*$ ]]; then
                echo "  Skipping $ACTION_NAME@$ACTION_VERSION (not a versioned tag)"
                continue
              fi

              echo "  Checking $ACTION_NAME@$ACTION_VERSION..."

              # Add verification of GitHub Action publisher
              PUBLISHER=""
              if [[ "$ACTION_NAME" =~ ^github/ ]]; then
                PUBLISHER="github"
              elif [[ "$ACTION_NAME" =~ ^oven-sh/ ]]; then
                PUBLISHER="oven-sh"
              fi

              # If trusted publisher, continue with version check
              if [ -n "$PUBLISHER" ]; then
                echo "  ‚úÖ Trusted publisher: $PUBLISHER"
              else
                echo "  ‚ö†Ô∏è Publisher verification: Unknown publisher $ACTION_NAME"
              fi

              # Get latest release through GitHub API
              if [[ "$ACTION_NAME" =~ ^[a-zA-Z0-9_\-]+/[a-zA-Z0-9_\-]+$ ]]; then
                # Handle standard GitHub repo format (owner/repo)
                LATEST_VERSION=$(curl -s -H "Accept: application/vnd.github.v3+json" \
                  https://api.github.com/repos/$ACTION_NAME/releases/latest | \
                  jq -r '.tag_name // "not_found"' 2>/dev/null || echo "not_found")
              else
                # Handle other formats (might be GitHub Marketplace actions)
                LATEST_VERSION="unknown"
              fi

              if [ "$LATEST_VERSION" != "not_found" ] && [ "$LATEST_VERSION" != "unknown" ] && [ "$LATEST_VERSION" != "$ACTION_VERSION" ]; then
                echo "  ‚úÖ Update available: $ACTION_NAME@$ACTION_VERSION -> $LATEST_VERSION"
                ACTION_UPDATES_AVAILABLE=true
                ACTION_UPDATE_COUNT=$((ACTION_UPDATE_COUNT + 1))

                # Save update info to file for later processing
                echo "$ACTION_NAME,$ACTION_VERSION,$LATEST_VERSION,$file,$PUBLISHER" >> action_updates.csv
              fi
            done <<< "$ACTIONS"
          }

          # Create output file
          touch action_updates.csv

          # Check all workflow files
          for FILE in .github/workflows/*.yml; do
            [ -f "$FILE" ] && check_workflow_file "$FILE"
          done

          # Set outputs
          echo "actions_update_available=$ACTION_UPDATES_AVAILABLE" >> $GITHUB_OUTPUT
          echo "actions_update_count=$ACTION_UPDATE_COUNT" >> $GITHUB_OUTPUT

          if [ "$ACTION_UPDATES_AVAILABLE" = true ]; then
            echo "‚úÖ Found $ACTION_UPDATE_COUNT GitHub Action updates available"

            # Get some examples for the summary
            if [ -f "action_updates.csv" ] && [ -s "action_updates.csv" ]; then
              EXAMPLES=$(head -3 action_updates.csv | awk -F, '{print $1 "@" $2 " -> " $3}' | paste -sd ", " -)
              echo "actions_update_examples=$EXAMPLES" >> $GITHUB_OUTPUT
            fi
          else
            echo "‚ö†Ô∏è No GitHub Action updates available"
          fi
          echo "::endgroup::"

      - name: "üìä Generate Results Summary"
        id: summary
        run: |
          echo "::group::Generating summary"

          # Determine if any updates are available
          NPM_UPDATES="${{ steps.check-npm.outputs.updates_available || 'false' }}"
          BUN_UPDATES="${{ steps.check-bun.outputs.bun_update_available || 'false' }}"
          ACTION_UPDATES="${{ steps.check-actions.outputs.actions_update_available || 'false' }}"
          VULNERABILITIES="${{ steps.vuln-scan.outputs.vulnerabilities_found || 'false' }}"

          # Store additional values with default fallbacks for safety
          NPM_UPDATE_COUNT="${{ steps.check-npm.outputs.update_count || '0' }}"
          NPM_UPDATE_EXAMPLES="${{ steps.check-npm.outputs.update_examples || 'information not available' }}"
          BUN_UPDATE_TYPE="${{ steps.check-bun.outputs.bun_update_type || 'unknown' }}"
          BUN_CURRENT_VERSION="${{ steps.check-bun.outputs.bun_current_version || 'unknown' }}"
          BUN_LATEST_VERSION="${{ steps.check-bun.outputs.bun_latest_version || 'unknown' }}"
          CURRENT_BUN_VERSION="${{ steps.analyze-config.outputs.bun_version || 'unknown' }}"
          ACTIONS_UPDATE_COUNT="${{ steps.check-actions.outputs.actions_update_count || '0' }}"
          ACTIONS_UPDATE_EXAMPLES="${{ steps.check-actions.outputs.actions_update_examples || 'information not available' }}"
          HIGH_VULNS="${{ steps.vuln-scan.outputs.high_vulns || '0' }}"
          CRITICAL_VULNS="${{ steps.vuln-scan.outputs.critical_vulns || '0' }}"
          SBOM_FORMAT="${{ steps.generate-sbom.outputs.sbom_format || 'CycloneDX' }}"
          SBOM_COMPONENT_COUNT="${{ steps.generate-sbom.outputs.sbom_component_count || '0' }}"
          USES_BUN="${{ steps.analyze-config.outputs.uses_bun || 'false' }}"
          SBOM_GENERATED="${{ steps.generate-sbom.outputs.sbom_generated || 'false' }}"

          if [ "$NPM_UPDATES" = "true" ] || [ "$BUN_UPDATES" = "true" ] || [ "$ACTION_UPDATES" = "true" ]; then
            echo "any_updates_available=true" >> $GITHUB_OUTPUT
            echo "‚úÖ Updates available!"
          else
            echo "any_updates_available=false" >> $GITHUB_OUTPUT
            echo "‚ö†Ô∏è No updates available"
          fi

          # Create a detailed summary
          {
            echo "# üìä Dependency Update Summary"
            echo ""

            # Add security summary first
            if [ "${{ env.VULN_SCAN }}" = "true" ]; then
              echo "## üîí Security Status"
              if [ "$VULNERABILITIES" = "true" ]; then
                echo "- ‚ö†Ô∏è **Vulnerabilities detected**: $HIGH_VULNS high, $CRITICAL_VULNS critical"
                echo "- üö® **Action required**: Update dependencies to resolve security issues"
              else
                echo "- ‚úÖ **No vulnerabilities detected**"
              fi
              echo ""
            fi

            # Add SBOM information
            if [ "${{ env.GENERATE_SBOM }}" = "true" ] && [ "$SBOM_GENERATED" = "true" ]; then
              echo "## üìã Software Bill of Materials"
              echo "- ‚úÖ **SBOM generated**: $SBOM_FORMAT format"
              echo "- üìä **Components**: $SBOM_COMPONENT_COUNT tracked dependencies"
              echo ""
            fi

            echo "## üîç Scan Results"
            echo ""

            if [ "$NPM_UPDATES" = "true" ]; then
              echo "### üì¶ NPM Packages"
              echo "- ‚úÖ **$NPM_UPDATE_COUNT** package updates available"
              echo "- Examples: $NPM_UPDATE_EXAMPLES"
              echo ""
            else
              echo "### üì¶ NPM Packages"
              echo "- ‚ö†Ô∏è No updates available"
              echo ""
            fi

            if [ "$USES_BUN" = "true" ]; then
              echo "### üèÉ Bun Runtime"
              if [ "$BUN_UPDATES" = "true" ]; then
                echo "- ‚úÖ **$BUN_UPDATE_TYPE** update available: $BUN_CURRENT_VERSION ‚Üí $BUN_LATEST_VERSION"
              else
                echo "- ‚ö†Ô∏è Already at latest version ($CURRENT_BUN_VERSION)"
              fi
              echo ""
            fi

            echo "### üîÑ GitHub Actions"
            if [ "$ACTION_UPDATES" = "true" ]; then
              echo "- ‚úÖ **$ACTIONS_UPDATE_COUNT** action updates available"
              if [ -n "$ACTIONS_UPDATE_EXAMPLES" ]; then
                echo "- Examples: $ACTIONS_UPDATE_EXAMPLES"
              fi
            else
              echo "- ‚ö†Ô∏è No updates available"
            fi
            echo ""

            if [ "${{ env.DRY_RUN }}" = "true" ]; then
              echo "## ‚ÑπÔ∏è Dry Run Mode"
              echo "No actual updates will be applied. This is just a scan."
            else
              if [ "$NPM_UPDATES" = "true" ] || [ "$BUN_UPDATES" = "true" ] || [ "$ACTION_UPDATES" = "true" ] || [ "$VULNERABILITIES" = "true" ]; then
                echo "## üöÄ Next Steps"
                if [ "$VULNERABILITIES" = "true" ]; then
                  echo "**Security vulnerabilities detected!** Dependabot will be triggered to create security update PRs."
                  echo ""
                fi
                echo "Dependabot will be triggered to create PRs for these updates."
              else
                echo "## ‚ÑπÔ∏è No Updates Required"
                echo "All dependencies are already up to date."
              fi
            fi
          } > dependency_summary.md

          echo "::endgroup::"

      - name: "üì§ Upload Summary Artifact"
        uses: actions/upload-artifact@v4
        with:
          name: dependency-scan-summary
          path: |
            dependency_summary.md
            sbom.json
          retention-days: 7

      - name: "üìÉ Output Summary to Steps"
        run: cat dependency_summary.md >> $GITHUB_STEP_SUMMARY

      # Add SARIF vulnerability report
      - name: "üö® Upload Vulnerability Report"
        if: env.VULN_SCAN == 'true' && steps.vuln-scan.outputs.vulnerabilities_found == 'true'
        uses: github/codeql-action/upload-sarif@v3
        with:
          sarif_file: npm-audit.sarif
          category: dependency-check

      # -------------------------------------------------------
      # üîê Setup GPG for Commit Signing
      # -------------------------------------------------------
      - name: "üîê Setup GPG for Commit Signing"
        id: gpg-setup
        if: steps.summary.outputs.any_updates_available == 'true' && env.DRY_RUN != 'true'
        run: |
          echo "::group::GPG Setup"
          # Only proceed if GPG keys are provided
          if [[ -n "${{ secrets.GPG_PRIVATE_KEY }}" && -n "${{ secrets.GPG_PASSPHRASE }}" ]]; then
            echo "Setting up GPG key for signed commits"

            # Install gnupg if needed
            which gpg > /dev/null || { sudo apt-get update -qq && sudo apt-get install -qq -y gnupg; }

            # Create temporary file for GPG key
            GPG_KEY_FILE=$(mktemp)
            chmod 600 "$GPG_KEY_FILE"
            echo "${{ secrets.GPG_PRIVATE_KEY }}" | base64 -d > "$GPG_KEY_FILE"

            # Import the GPG key
            echo "${{ secrets.GPG_PASSPHRASE }}" | gpg --batch --yes --passphrase-fd 0 --import "$GPG_KEY_FILE"

            # Get the key ID
            KEY_ID=$(gpg --list-secret-keys --keyid-format LONG | grep sec | head -n1 | awk '{print $2}' | cut -d'/' -f2)

            # Configure Git to use the imported GPG key
            git config --global user.signingkey "$KEY_ID"
            git config --global commit.gpgsign true

            # Set commit author identity from secrets
            git config --global user.name "${{ secrets.GIT_COMMITTER_NAME || github.repository_owner }}"
            git config --global user.email "${{ secrets.GIT_COMMITTER_EMAIL || 'github-actions@github.com' }}"

            # Secure cleanup
            rm -f "$GPG_KEY_FILE"

            echo "signing_enabled=true" >> $GITHUB_OUTPUT
            echo "key_id=$KEY_ID" >> $GITHUB_OUTPUT
            echo "GPG signing enabled with key: $KEY_ID"
          else
            echo "GPG signing not configured - using standard commits"
            git config --global user.name "github-actions[bot]"
            git config --global user.email "41898282+github-actions[bot]@users.noreply.github.com"

            echo "signing_enabled=false" >> $GITHUB_OUTPUT
          fi
          echo "::endgroup::"

      # -------------------------------------------------------
      # üîÑ Update NPM Dependencies
      # -------------------------------------------------------
      - name: "üîÑ Update NPM Dependencies"
        if: env.CHECK_TYPE == 'all' || env.CHECK_TYPE == 'npm' && steps.check-npm.outputs.updates_available == 'true' && env.DRY_RUN != 'true'
        id: update-npm
        run: |
          echo "::group::Updating NPM Dependencies"

          # Setup Bun if it's used in the project
          if [ "${{ steps.analyze-config.outputs.uses_bun }}" == "true" ]; then
            echo "üîπ Setting up Bun runtime..."
            curl -fsSL https://bun.sh/install | bash
            export BUN_INSTALL="$HOME/.bun"
            export PATH="$BUN_INSTALL/bin:$PATH"
          fi

          # Check if JSON data exists
          if [ ! -f "npm-updates.json" ]; then
            echo "‚ö†Ô∏è No update information found"
            echo "::endgroup::"
            exit 0
          fi

          # Read the update data
          UPDATES=$(cat npm-updates.json)

          # Create a temporary file for filtered updates
          echo "{}" > minor-patch-updates.json

          # Filter updates to include only minor and patch versions
          echo "üîπ Filtering for minor and patch updates only..."
          MINOR_PATCH_COUNT=0

          # Loop through each update to determine if it's minor or patch
          for pkg in $(echo "$UPDATES" | jq -r 'keys[]'); do
            CURRENT=$(echo "$UPDATES" | jq -r ".[\"$pkg\"].from" || echo "0.0.0")
            TARGET=$(echo "$UPDATES" | jq -r ".[\"$pkg\"].to" || echo "0.0.0")

            # Extract major.minor.patch
            CURRENT_MAJOR=$(echo "$CURRENT" | sed -E 's/^([0-9]+)\..*/\1/')
            CURRENT_MINOR=$(echo "$CURRENT" | sed -E 's/^[0-9]+\.([0-9]+)\..*/\1/')
            TARGET_MAJOR=$(echo "$TARGET" | sed -E 's/^([0-9]+)\..*/\1/')
            TARGET_MINOR=$(echo "$TARGET" | sed -E 's/^[0-9]+\.([0-9]+)\..*/\1/')

            # Only include if it's minor or patch update
            if [ "$TARGET_MAJOR" = "$CURRENT_MAJOR" ]; then
              # Add to our filtered updates
              jq --arg pkg "$pkg" --arg ver "$TARGET" '.[$pkg] = $ver' minor-patch-updates.json > tmp.json
              mv tmp.json minor-patch-updates.json
              MINOR_PATCH_COUNT=$((MINOR_PATCH_COUNT + 1))

              if [ "$TARGET_MINOR" -gt "$CURRENT_MINOR" ]; then
                echo "üîπ Minor update: $pkg $CURRENT -> $TARGET"
              else
                echo "üîπ Patch update: $pkg $CURRENT -> $TARGET"
              fi
            else
              echo "üîπ Skipping major update: $pkg $CURRENT -> $TARGET"
            fi
          done

          echo "üîπ Found $MINOR_PATCH_COUNT minor/patch updates to apply"
          echo "minor_patch_count=$MINOR_PATCH_COUNT" >> $GITHUB_OUTPUT

          if [ "$MINOR_PATCH_COUNT" -eq 0 ]; then
            echo "‚ö†Ô∏è No minor or patch updates to apply"
            echo "::endgroup::"
            exit 0
          fi

          # Create a new branch for the updates
          BRANCH_NAME="auto-update-deps-$(date +"%Y%m%d%H%M%S")"
          git checkout -b "$BRANCH_NAME"

          # Apply the updates
          if [ "${{ steps.analyze-config.outputs.uses_bun }}" == "true" ]; then
            # Use Bun to update dependencies
            echo "üîπ Applying updates with Bun..."
            for pkg in $(jq -r 'keys[]' minor-patch-updates.json); do
              version=$(jq -r ".\"$pkg\"" minor-patch-updates.json)
              if jq -e '.dependencies["'$pkg'"]' package.json > /dev/null; then
                echo "üîπ Updating dependency: $pkg to $version"
                bun add "$pkg@$version"
              elif jq -e '.devDependencies["'$pkg'"]' package.json > /dev/null; then
                echo "üîπ Updating dev dependency: $pkg to $version"
                bun add -d "$pkg@$version"
              fi
            done
          else
            # Use npm to update dependencies
            echo "üîπ Applying updates with npm..."
            for pkg in $(jq -r 'keys[]' minor-patch-updates.json); do
              version=$(jq -r ".\"$pkg\"" minor-patch-updates.json)
              if jq -e '.dependencies["'$pkg'"]' package.json > /dev/null; then
                echo "üîπ Updating dependency: $pkg to $version"
                npm install --save "$pkg@$version"
              elif jq -e '.devDependencies["'$pkg'"]' package.json > /dev/null; then
                echo "üîπ Updating dev dependency: $pkg to $version"
                npm install --save-dev "$pkg@$version"
              fi
            done
          fi

          # Check if there are actually changes to commit
          if git diff --quiet package.json; then
            echo "‚ö†Ô∏è No changes to package.json, nothing to commit"
          else
            # Format the updated package.json
            if command -v prettier > /dev/null && [ -f ".prettierrc" ]; then
              echo "üîπ Formatting package.json with prettier..."
              npx prettier --write package.json
            fi

            # Commit the changes with signed commit if enabled
            echo "üîπ Committing changes..."
            git add package.json package-lock.json bun.lockb 2>/dev/null || git add package.json

            # Create detailed commit message
            UPDATE_LIST=$(jq -r 'to_entries | map("  - \(.key): \(.value)") | join("\n")' minor-patch-updates.json)
            COMMIT_MSG="deps: update dependencies with minor and patch updates\n\nUpdates the following dependencies:\n$UPDATE_LIST"

            # Perform the commit
            if [ "${{ steps.gpg-setup.outputs.signing_enabled }}" == "true" ]; then
              echo "üîπ Creating signed commit..."
              echo "${{ secrets.GPG_PASSPHRASE }}" | gpg --batch --yes --passphrase-fd 0 --pinentry-mode loopback -o /dev/null --sign - 2>/dev/null || true
              git commit -S -m "$(echo -e "$COMMIT_MSG")"
            else
              echo "üîπ Creating commit (unsigned)..."
              git commit -m "$(echo -e "$COMMIT_MSG")"
            fi

            # Push the changes
            echo "üîπ Pushing changes..."
            git push origin "$BRANCH_NAME"

            # Create PR
            echo "üîπ Creating pull request..."
            PR_URL=$(curl -s -X POST \
              -H "Authorization: token ${{ secrets.GITHUB_TOKEN }}" \
              -H "Accept: application/vnd.github.v4+json" \
              https://api.github.com/repos/${{ github.repository }}/pulls \
              -d "{
                \"title\": \"deps: update minor and patch dependencies\",
                \"body\": \"Automated dependency updates for minor and patch versions.\n\nUpdated packages:\n$UPDATE_LIST\",
                \"head\": \"$BRANCH_NAME\",
                \"base\": \"master\"
              }" | jq -r '.html_url')

            echo "‚úÖ Pull request created: $PR_URL"
            echo "pr_url=$PR_URL" >> $GITHUB_OUTPUT
          fi
          echo "::endgroup::"

      # -------------------------------------------------------
      # üîÑ Update Bun Runtime
      # -------------------------------------------------------
      - name: "üîÑ Update Bun Runtime"
        if: (env.CHECK_TYPE == 'all' || env.CHECK_TYPE == 'bun-runtime') && steps.check-bun.outputs.bun_update_available == 'true' && steps.check-bun.outputs.bun_update_type != 'major' && env.DRY_RUN != 'true'
        id: update-bun
        run: |
          echo "::group::Updating Bun Runtime"
          # Only update if it's a minor or patch update
          if [ "${{ steps.check-bun.outputs.bun_update_type }}" == "major" ]; then
            echo "‚ö†Ô∏è Major Bun update detected - skipping automated update"
            echo "::endgroup::"
            exit 0
          fi

          # Get the versions
          NEW_VERSION="${{ steps.check-bun.outputs.bun_latest_version }}"
          OLD_VERSION="${{ steps.check-bun.outputs.bun_current_version }}"

          echo "üîπ Updating Bun from $OLD_VERSION to $NEW_VERSION..."

          # Create a branch for the update
          BRANCH_NAME="bun-update-$NEW_VERSION-$(date +"%Y%m%d%H%M%S")"
          git checkout -b "$BRANCH_NAME"

          # Update packageManager in package.json
          echo "üîπ Updating packageManager in package.json"
          jq --arg ver "$NEW_VERSION" '.packageManager = "bun@" + $ver' package.json > package.json.tmp
          mv package.json.tmp package.json

          # Update engines.bun field if it exists
          if jq -e '.engines.bun' package.json > /dev/null 2>&1; then
            echo "üîπ Updating engines.bun in package.json"
            # Get only major.minor from new version
            MAJOR_MINOR=$(echo "$NEW_VERSION" | cut -d. -f1-2)

            # Check format (^ or >= prefix)
            if grep -q '"bun": *">=' package.json; then
              jq --arg ver "$MAJOR_MINOR.0" '.engines.bun = ">=" + $ver' package.json > package.json.tmp
              mv package.json.tmp package.json
            elif grep -q '"bun": *"\\^' package.json; then
              jq --arg ver "$MAJOR_MINOR.0" '.engines.bun = "^" + $ver' package.json > package.json.tmp
              mv package.json.tmp package.json
            fi
          fi

          # Update BUN_VERSION in workflow files
          echo "üîπ Updating BUN_VERSION in workflow files"
          for file in .github/workflows/*.yml; do
            if grep -q "BUN_VERSION:" "$file"; then
              sed -i -E "s/(BUN_VERSION: *\")[0-9]+\.[0-9]+\.[0-9]+(\" *#.*)/\1$NEW_VERSION\2/" "$file"
            fi
          done

          # Format the package.json if prettier is available
          if command -v prettier > /dev/null && [ -f ".prettierrc" ]; then
            echo "üîπ Formatting package.json with prettier..."
            npx prettier --write package.json
          fi

          # Commit changes with a signed commit
          echo "üîπ Committing changes..."
          git add package.json .github/workflows/*.yml

          # Create detailed commit message
          COMMIT_MSG="deps(bun): update bun from $OLD_VERSION to $NEW_VERSION\n\nAutomated update of Bun runtime version in:\n- packageManager field in package.json\n- BUN_VERSION in workflow files"

          # Perform the commit
          if [ "${{ steps.gpg-setup.outputs.signing_enabled }}" == "true" ]; then
            echo "üîπ Creating signed commit..."
            echo "${{ secrets.GPG_PASSPHRASE }}" | gpg --batch --yes --passphrase-fd 0 --pinentry-mode loopback -o /dev/null --sign - 2>/dev/null || true
            git commit -S -m "$(echo -e "$COMMIT_MSG")"
          else
            echo "üîπ Creating commit (unsigned)..."
            git commit -m "$(echo -e "$COMMIT_MSG")"
          fi

          # Push the changes
          echo "üîπ Pushing changes..."
          git push origin "$BRANCH_NAME"

          # Create PR
          echo "üîπ Creating pull request..."
          PR_URL=$(curl -s -X POST \
            -H "Authorization: token ${{ secrets.GITHUB_TOKEN }}" \
            -H "Accept: application/vnd.github.v4+json" \
            https://api.github.com/repos/${{ github.repository }}/pulls \
            -d "{
              \"title\": \"deps(bun): update bun from $OLD_VERSION to $NEW_VERSION\",
              \"body\": \"Automated update of Bun runtime from $OLD_VERSION to $NEW_VERSION.\",
              \"head\": \"$BRANCH_NAME\",
              \"base\": \"master\"
            }" | jq -r '.html_url')

          echo "‚úÖ Pull request created: $PR_URL"
          echo "pr_url=$PR_URL" >> $GITHUB_OUTPUT
          echo "::endgroup::"

      # -------------------------------------------------------
      # üîÑ Update GitHub Actions
      # -------------------------------------------------------
      - name: "üîÑ Update GitHub Actions"
        if: (env.CHECK_TYPE == 'all' || env.CHECK_TYPE == 'github-actions') && steps.check-actions.outputs.actions_update_available == 'true' && env.DRY_RUN != 'true'
        id: update-actions
        run: |
          echo "::group::Updating GitHub Actions"
          if [ ! -f "action_updates.csv" ] || [ ! -s "action_updates.csv" ]; then
            echo "‚ö†Ô∏è No action updates found"
            echo "::endgroup::"
            exit 0
          fi

          # Create a branch for updates
          BRANCH_NAME="action-updates-$(date +"%Y%m%d%H%M%S")"
          git checkout -b "$BRANCH_NAME"

          # Track changes
          UPDATED_ACTIONS=()
          UPDATED_FILES=()

          # Read the CSV file
          while IFS=, read -r ACTION_NAME ACTION_VERSION LATEST_VERSION FILE PUBLISHER; do
            if [ -z "$ACTION_NAME" ] || [ -z "$ACTION_VERSION" ] || [ -z "$LATEST_VERSION" ] || [ -z "$FILE" ]; then
              continue
            fi

            # Only update from trusted publishers or explicitly approved actions
            if [[ "$PUBLISHER" == "github" ]] || [[ "$PUBLISHER" == "oven-sh" ]] || [[ "$ACTION_NAME" == "actions/checkout" ]] || [[ "$ACTION_NAME" == "actions/setup-node" ]]; then
              echo "üîπ Updating trusted action: $ACTION_NAME from $ACTION_VERSION to $LATEST_VERSION in $FILE"

              # Use sed to update the action version in the workflow file
              sed -i "s|uses: $ACTION_NAME@$ACTION_VERSION|uses: $ACTION_NAME@$LATEST_VERSION|g" "$FILE"

              # Track what we updated
              UPDATED_ACTIONS+=("$ACTION_NAME: $ACTION_VERSION ‚Üí $LATEST_VERSION")

              # Add file to tracking if not already there
              if [[ ! " ${UPDATED_FILES[*]} " =~ " ${FILE} " ]]; then
                UPDATED_FILES+=("$FILE")
              fi
            else
              echo "‚ö†Ô∏è Skipping update for untrusted publisher: $ACTION_NAME ($PUBLISHER)"
            fi
          done < action_updates.csv

          # Check if we have any updates
          if [ ${#UPDATED_ACTIONS[@]} -eq 0 ]; then
            echo "‚ö†Ô∏è No trusted actions to update"
            echo "::endgroup::"
            exit 0
          fi

          # Commit the changes
          echo "üîπ Committing updates for ${#UPDATED_ACTIONS[@]} actions..."
          git add "${UPDATED_FILES[@]}"

          # Build commit message
          ACTIONS_LIST=$(printf "  - %s\n" "${UPDATED_ACTIONS[@]}")
          COMMIT_MSG="ci: update GitHub Actions to latest versions\n\nUpdated actions:\n$ACTIONS_LIST"

          # Perform the commit
          if [ "${{ steps.gpg-setup.outputs.signing_enabled }}" == "true" ]; then
            echo "üîπ Creating signed commit..."
            echo "${{ secrets.GPG_PASSPHRASE }}" | gpg --batch --yes --passphrase-fd 0 --pinentry-mode loopback -o /dev/null --sign - 2>/dev/null || true
            git commit -S -m "$(echo -e "$COMMIT_MSG")"
          else
            echo "üîπ Creating commit (unsigned)..."
            git commit -m "$(echo -e "$COMMIT_MSG")"
          fi

          # Push the changes
          echo "üîπ Pushing changes..."
          git push origin "$BRANCH_NAME"

          # Create PR
          echo "üîπ Creating pull request..."
          PR_URL=$(curl -s -X POST \
            -H "Authorization: token ${{ secrets.GITHUB_TOKEN }}" \
            -H "Accept: application/vnd.github.v4+json" \
            https://api.github.com/repos/${{ github.repository }}/pulls \
            -d "{
              \"title\": \"ci: update GitHub Actions to latest versions\",
              \"body\": \"Automated update of GitHub Actions.\n\nUpdated actions:\n$(printf \"- %s\n\" \"${UPDATED_ACTIONS[@]}\")\",
              \"head\": \"$BRANCH_NAME\",
              \"base\": \"master\"
            }" | jq -r '.html_url')

          echo "‚úÖ Pull request created: $PR_URL"
          echo "pr_url=$PR_URL" >> $GITHUB_OUTPUT
          echo "::endgroup::"

      - name: "üöÄ Trigger Dependabot"
        if: steps.summary.outputs.any_updates_available == 'true' && env.DRY_RUN != 'true' && (steps.check-bun.outputs.bun_update_type == 'major' || steps.vuln-scan.outputs.vulnerabilities_found == 'true')
        run: |
          echo "::group::Triggering Dependabot for Major Updates and Security Fixes"

          # Check if Dependabot is configured
          if [ "${{ steps.analyze-config.outputs.dependabot_config_exists }}" != "true" ]; then
            echo "‚ö†Ô∏è Cannot trigger Dependabot - No dependabot.yml configuration found"
            echo "::endgroup::"
            exit 0
          fi

          # Prepare API data
          if [ "${{ env.CHECK_TYPE }}" = "all" ]; then
            ECOSYSTEMS="npm,github-actions"
          elif [ "${{ env.CHECK_TYPE }}" = "npm" ]; then
            ECOSYSTEMS="npm"
          elif [ "${{ env.CHECK_TYPE }}" = "github-actions" ]; then
            ECOSYSTEMS="github-actions"
          elif [ "${{ env.CHECK_TYPE }}" = "bun-runtime" ]; then
            ECOSYSTEMS="npm"  # Bun updates come through npm ecosystem
          fi

          # Prioritize security updates
          if [ "${{ steps.vuln-scan.outputs.vulnerabilities_found }}" == "true" ]; then
            echo "üîí Prioritizing security updates due to vulnerabilities detected"
            SECURITY_PARAM=",\"security-updates-only\":true"
          else
            SECURITY_PARAM=""
          fi

          echo "üîπ Triggering dependency update check for: $ECOSYSTEMS"

          # GitHub API call to trigger Dependabot with latest parameters
          curl -X POST \
            -H "Accept: application/vnd.github.v3+json" \
            -H "Authorization: token ${{ secrets.GITHUB_TOKEN }}" \
            https://api.github.com/repos/${{ github.repository }}/dependabot/scans \
            -d '{"dependency-names":[],"directory":"/","package-ecosystem":"'"$ECOSYSTEMS"'"'"$SECURITY_PARAM"'}'

          echo "::endgroup::"

          echo "‚úÖ Dependabot update scan triggered successfully!"

      - name: "üì£ Notify No Updates Available"
        if: steps.summary.outputs.any_updates_available != 'true' && env.DRY_RUN != 'true'
        run: |
          echo "::notice title=All dependencies up to date::No dependency updates are currently available. Everything is already on the latest version."
