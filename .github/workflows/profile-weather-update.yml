name: "üå¶Ô∏è Profile Weather Update"
      
# ============================================================
# üöÄ Optimized triggers for reliability and performance
# ============================================================
on:
  schedule:
    # Strategic times that capture meaningful weather changes while conserving resources
    - cron: "23 5,13,21 * * *"  # 3 times daily: morning (5:23), afternoon (13:23), evening (21:23)

  workflow_dispatch:
    inputs:
      force_update:
        description: "Force README update regardless of changes"
        type: boolean
        default: false
      skip_tests:
        description: "Skip test execution"
        type: boolean
        default: false

# ============================================================
# üöÄ Prevent redundant executions (Ensures single execution)
# ============================================================
concurrency:
  group: ${{ github.workflow }}-${{ github.ref }}
  cancel-in-progress: false

# ============================================================
# üîí Explicit permissions (Principle of least privilege)
# ============================================================
permissions:
  contents: write  # For repository updates
  id-token: write  # For OIDC token (keyless signing)

# ============================================================
# üåç Global environment variables
# ============================================================
env:
  CACHE_KEY_PREFIX: "v10-profile-weather"
  TIMEZONE: "Asia/Dhaka"
  PROFILE_REPO: "tashfiqul-islam/tashfiqul-islam"  # README.md repository
  NODE_ENV: "production"
  FORCE_UPDATE: ${{ github.event.inputs.force_update || 'false' }}
  SKIP_TESTS: ${{ github.event.inputs.skip_tests || 'false' }}

# ============================================================
# üìå JOB: UPDATE WEATHER (Main execution)
# ============================================================
jobs:
  update-weather:
    name: "üå¶Ô∏è Update Weather Data"
    runs-on: ubuntu-latest
    timeout-minutes: 5
    outputs:
      api_response_time: ${{ steps.update-weather-and-readme.outputs.API_RESPONSE_TIME }}
      cache_hit: ${{ steps.cache-deps.outputs.cache-hit }}
      changes_detected: ${{ steps.update-weather-and-readme.outputs.changes_detected }}

    steps:
      - name: "‚¨áÔ∏è Checkout Weather Code Repository"
        uses: actions/checkout@v4
        with:
          repository: ${{ github.repository }}
          fetch-depth: 0  # Full history for better caching
          persist-credentials: false  # Security best practice

      - name: "‚¨áÔ∏è Checkout Profile Repository"
        uses: actions/checkout@v4
        with:
          repository: ${{ env.PROFILE_REPO }}
          path: profile-repo
          token: ${{ secrets.PAT }}
          fetch-depth: 1  # Shallow for profile repo (we only need latest)
          ref: master
          persist-credentials: false  # Security best practice

      - name: "üèóÔ∏è Setup Bun"
        uses: oven-sh/setup-bun@v2
        with:
          bun-version: latest

      - name: "üß∞ Setup Node (for tooling)"
        uses: actions/setup-node@v4
        with:
          node-version: "lts/*"

      - name: "üì¶ Restore Dependencies Cache"
        id: cache-deps
        uses: actions/cache/restore@v4
        with:
          path: |
            node_modules
            ~/.bun/install/cache
            bun.lock
          key: ${{ env.CACHE_KEY_PREFIX }}-${{ runner.os }}-bun-${{ hashFiles('package.json', 'bun.lock') }}
          restore-keys: |
            ${{ env.CACHE_KEY_PREFIX }}-${{ runner.os }}-bun-

      - name: "üîÑ Install Dependencies"
        if: steps.cache-deps.outputs.cache-hit != 'true'
        run: |
          echo "::group::Bun Installation"
          bun --version
          bun install --frozen-lockfile
          echo "::endgroup::"

      - name: "‚ö° Install Dependencies (Fast Path)"
        if: steps.cache-deps.outputs.cache-hit == 'true'
        run: |
          echo "::notice::Using cached dependencies"
          bun install --frozen-lockfile --no-summary

      - name: "üîç Code Quality Check"
        if: env.SKIP_TESTS != 'true'
        run: |
          echo "::group::Code Quality Verification"
          bun run lint
          echo "::endgroup::"
          echo "::notice::Code quality checks passed"

      - name: "üìã Run Type Check"
        if: env.SKIP_TESTS != 'true'
        run: bun run type-check

      - name: "üß™ Run Tests"
        if: env.SKIP_TESTS != 'true'
        run: |
          echo "::group::Test Execution"
          bun run test
          echo "::endgroup::"
        env:
          OPEN_WEATHER_KEY: "mock-api-key-for-tests"
          CI: "true"

      - name: "‚ö° Skip Quality Checks (Fast Mode)"
        if: env.SKIP_TESTS == 'true'
        run: |
          echo "::notice::Skipping quality checks for faster execution"
          echo "‚ö†Ô∏è Quality checks disabled - use with caution"

      - name: "üìù Verify Profile README"
        run: |
          echo "::group::README Verification"
          if [[ ! -f "profile-repo/README.md" ]]; then
            echo "::error::README.md file not found in profile repository"
            exit 1
          fi

          if ! grep -q "<!-- Hourly Weather Update -->" profile-repo/README.md; then
            echo "::error::Weather section not found in README.md"
            exit 1
          fi
          echo "::notice::Weather section found in profile README"
          echo "::endgroup::"

      - name: "üå¶Ô∏è Update Weather and README"
        id: update-weather-and-readme
        env:
          OPEN_WEATHER_KEY: ${{ secrets.OPEN_WEATHER_KEY }}
          GITHUB_ACTIONS: "true"
          PROFILE_README_PATH: "../profile-repo/README.md"
          FORCE_UPDATE: ${{ env.FORCE_UPDATE }}
        run: |
          echo "::group::Weather Update Process"
          
          # Performance monitoring setup
          START_TIME=$(date +%s.%N)
          echo "üöÄ Starting weather update at $(date)"
          
          # Log the README path to verify it's correct
          echo "README path: $PROFILE_README_PATH"
          if [[ -f "$PROFILE_README_PATH" ]]; then
            echo "‚úÖ README file exists at path"
          else
            echo "::error::README file not found at specified path"
            exit 1
          fi

          # Execute the TypeScript code to fetch weather and update README
          echo "üåç Fetching weather data..."
          OUTPUT=$(bun run src/weather-update/index.ts)

          # Performance metrics
          END_TIME=$(date +%s.%N)
          ELAPSED_TIME=$(echo "$END_TIME - $START_TIME" | bc)
          echo "API_RESPONSE_TIME=$ELAPSED_TIME" >> $GITHUB_OUTPUT
          echo "‚è±Ô∏è Total execution time: ${ELAPSED_TIME}s"
          
          # Performance thresholds
          if (( $(echo "$ELAPSED_TIME < 1.0" | bc -l) )); then
            echo "üöÄ Excellent performance: < 1s"
          elif (( $(echo "$ELAPSED_TIME < 2.0" | bc -l) )); then
            echo "‚úÖ Good performance: < 2s"
          else
            echo "‚ö†Ô∏è Performance warning: > 2s"
          fi

          # Echo the full output for debugging
          echo "Full script output:"
          echo "$OUTPUT"

          # Capture the execution status
          EXECUTION_STATUS=$?

          if [[ $EXECUTION_STATUS -ne 0 ]]; then
            echo "::error::Weather update process failed with code $EXECUTION_STATUS"
            echo "$OUTPUT" | grep -E '‚ùå|Error'
            exit $EXECUTION_STATUS
          fi

          # Parse output for CHANGES_DETECTED flag and set step output
          if echo "$OUTPUT" | grep -q "CHANGES_DETECTED=true"; then
            echo "changes_detected=true" >> $GITHUB_OUTPUT
            echo "::notice::README changes detected by TypeScript code"
          else
            # Override to force commit if force_update was requested
            if [[ "${{ env.FORCE_UPDATE }}" == "true" ]]; then
              echo "::notice::Force update requested - will commit README even without detected changes"
              echo "changes_detected=true" >> $GITHUB_OUTPUT
            else
              echo "changes_detected=false" >> $GITHUB_OUTPUT
              echo "::notice::No README changes needed"
            fi
          fi

          # Log key output lines for monitoring
          echo "$OUTPUT" | grep -E '‚úÖ|‚ö†Ô∏è|‚ùå|üåç|üìù|üéâ' || true

          echo "::endgroup::"

      - name: "üì§ Upload Weather Output Artifact"
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: weather-output-${{ github.run_id }}
          path: profile-repo/README.md
          retention-days: 7
          compression-level: 6
          if-no-files-found: warn

      - name: "üíæ Save Dependencies Cache"
        if: always() && steps.cache-deps.outputs.cache-hit != 'true'
        uses: actions/cache/save@v4
        with:
          path: |
            node_modules
            ~/.bun/install/cache
            bun.lock
          key: ${{ steps.cache-deps.outputs.cache-primary-key }}

      - name: "üîß Normalize GPG private key"
        if: github.event_name == 'schedule' || steps.update-weather-and-readme.outputs.changes_detected == 'true'
        id: normalize-gpg
        env:
          GPG_PRIVATE_KEY: ${{ secrets.GPG_PRIVATE_KEY }}
        run: |
          set -euo pipefail
          if [ -z "${GPG_PRIVATE_KEY}" ]; then
            echo "::error::Missing secret GPG_PRIVATE_KEY"; exit 1; fi
          tmpdir="$(mktemp -d)"
          raw="$tmpdir/key.raw"
          asc="$tmpdir/key.asc"
          printf '%s' "${GPG_PRIVATE_KEY}" > "$raw"
          if grep -q "BEGIN PGP PRIVATE KEY BLOCK" "$raw"; then
            tr -d '\r' < "$raw" > "$asc"
          else
            if printf '%s' "${GPG_PRIVATE_KEY}" | base64 -d > "$asc" 2>/dev/null && grep -q "BEGIN PGP PRIVATE KEY BLOCK" "$asc"; then
              :
            else
              printf '%s' "${GPG_PRIVATE_KEY}" | sed 's/\\n/\n/g' | tr -d '\r' > "$asc"
              if ! grep -q "BEGIN PGP PRIVATE KEY BLOCK" "$asc"; then
                echo "::error::GPG_PRIVATE_KEY is not ASCII-armored. Re-export with 'gpg --export-secret-keys --armor KEY_ID' and paste full block including BEGIN/END lines."; exit 1; fi
            fi
          fi
          if ! grep -q "END PGP PRIVATE KEY BLOCK" "$asc"; then
            echo "::error::GPG_PRIVATE_KEY footer missing. Ensure END line is present."; exit 1; fi
          {
            echo "key<<'EOF'"
            cat "$asc"
            echo "EOF"
          } >> "$GITHUB_OUTPUT"

      - name: "üîê Setup GPG for Commit Signing"
        id: gpg-setup
        if: github.event_name == 'schedule' || steps.update-weather-and-readme.outputs.changes_detected == 'true'
        uses: crazy-max/ghaction-import-gpg@v6.3.0
        with:
          gpg_private_key: ${{ steps.normalize-gpg.outputs.key }}
          passphrase: ${{ secrets.GPG_PASSPHRASE }}
          git_user_signingkey: true
          git_commit_gpgsign: true
          git_tag_gpgsign: true
          git_push_gpgsign: if-asked
        env:
          GPG_TTY: /dev/console

      - name: "üë§ Configure Git Identity"
        if: github.event_name == 'schedule' || steps.update-weather-and-readme.outputs.changes_detected == 'true'
        run: |
          git config --global user.name "${{ secrets.GIT_COMMITTER_NAME || github.repository_owner }}"
          git config --global user.email "${{ secrets.GIT_COMMITTER_EMAIL }}"

      - name: "üíæ Commit and Push Changes"
        if: github.event_name == 'schedule' || steps.update-weather-and-readme.outputs.changes_detected == 'true'
        working-directory: profile-repo
        env:
          GITHUB_TOKEN: ${{ secrets.PAT }}
        run: |
          echo "::group::Git Operations"
          
          # Optimize Git configuration for CI
          git config --global core.compression 9
          git config --global core.loosecompression 9
          git config --global pack.deltaCacheSize 2047m
          git config --global pack.packSizeLimit 2047m
          git config --global pack.windowMemory 2047m
          
          # Apply correct commit timestamp in Dhaka timezone
          export GIT_AUTHOR_DATE="$(TZ='Asia/Dhaka' date)"
          export GIT_COMMITTER_DATE="$GIT_AUTHOR_DATE"

          # Format the last updated time for commit message
          FORMATTED_DATE=$(TZ="Asia/Dhaka" date "+%Y-%m-%d %H:%M:%S %Z")

          # For scheduled runs or force update, always commit regardless of git diff
          if [[ "${{ github.event_name }}" == "schedule" || "${{ env.FORCE_UPDATE }}" == "true" ]]; then
            git add README.md
            git commit -S --no-verify -m "update(weather): refresh data for ${FORMATTED_DATE}"
            git push origin master
            echo "::notice::Changes pushed successfully with signed commit (scheduled/forced)"
          else
            # For manual runs, check if there are actual git changes
            if git diff --quiet -- README.md; then
              echo "No actual changes detected in README.md by git diff"
            else
              git add README.md
              git commit -S --no-verify -m "update(weather): refresh data for ${FORMATTED_DATE}"
              git push origin master && echo "::notice::Changes pushed successfully with signed commit"
            fi
          fi
          echo "::endgroup::"

  # ============================================================
  # üìå JOB: VERIFICATION (Ensures update success)
  # ============================================================
  verify:
    name: "‚úÖ Verify & Report"
    needs: update-weather
    if: always()
    runs-on: ubuntu-latest
    permissions:
      contents: read
    timeout-minutes: 2

    steps:
      - name: "üìä Generate Execution Report"
        run: |
          echo "::group::Execution Summary"
          echo "# Profile Weather Update Report" >> $GITHUB_STEP_SUMMARY
          echo "## Execution Details" >> $GITHUB_STEP_SUMMARY
          echo "- **Run ID:** ${{ github.run_id }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Time:** $(TZ='${{ env.TIMEZONE }}' date '+%Y-%m-%d %Z')" >> $GITHUB_STEP_SUMMARY
          echo "- **Trigger:** ${{ github.event_name }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Target Repository:** ${{ env.PROFILE_REPO }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Execution Mode:** ${{ env.FORCE_UPDATE == 'true' && 'Force Update' || 'Normal' }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Tests:** ${{ env.SKIP_TESTS == 'true' && 'Skipped' || 'Executed' }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Performance:** ${{ needs.update-weather.outputs.api_response_time || 'N/A' }}s" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "## Status" >> $GITHUB_STEP_SUMMARY
          echo "- **Weather Update:** ${{ needs.update-weather.result }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Cache Hit:** ${{ needs.update-weather.outputs.cache_hit || 'N/A' }}" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "## Performance Metrics" >> $GITHUB_STEP_SUMMARY
          if [[ "${{ needs.update-weather.outputs.api_response_time }}" ]]; then
            RESPONSE_TIME="${{ needs.update-weather.outputs.api_response_time }}"
            if (( $(echo "$RESPONSE_TIME < 1.0" | bc -l) )); then
              echo "- **Status:** üöÄ Excellent (< 1s)" >> $GITHUB_STEP_SUMMARY
            elif (( $(echo "$RESPONSE_TIME < 2.0" | bc -l) )); then
              echo "- **Status:** ‚úÖ Good (< 2s)" >> $GITHUB_STEP_SUMMARY
            else
              echo "- **Status:** ‚ö†Ô∏è Slow (> 2s)" >> $GITHUB_STEP_SUMMARY
            fi
            echo "- **Response Time:** ${RESPONSE_TIME}s" >> $GITHUB_STEP_SUMMARY
          fi
          echo "::endgroup::"

      - name: "‚è±Ô∏è Schedule Next Update"
        run: |
          NEXT_UPDATE_TIME=$(TZ="${{ env.TIMEZONE }}" date -d "+8 hours" "+%H:%M:%S %Z")
          echo "::notice title=Next Update::Scheduled for approximately ${NEXT_UPDATE_TIME}"
          echo "## Next Update" >> $GITHUB_STEP_SUMMARY
          echo "- **Scheduled for:** ${NEXT_UPDATE_TIME}" >> $GITHUB_STEP_SUMMARY

  # ============================================================
  # üìå JOB: RECOVERY (Retries on failure)
  # ============================================================
  recovery:
    name: "üîÑ Recovery Actions"
    needs: [update-weather, verify]
    if: always() && (needs.update-weather.result == 'failure' || needs.verify.result == 'failure')
    runs-on: ubuntu-latest
    timeout-minutes: 3

    steps:
      - name: "üîç Analyze Failure"
        run: |
          echo "::group::Failure Analysis"
          echo "# Workflow Failure Analysis" >> $GITHUB_STEP_SUMMARY
          echo "## Failed Jobs" >> $GITHUB_STEP_SUMMARY

          if [[ "${{ needs.update-weather.result }}" == "failure" ]]; then
            echo "- **Weather Update:** Failed" >> $GITHUB_STEP_SUMMARY
          fi

          if [[ "${{ needs.verify.result }}" == "failure" ]]; then
            echo "- **Verification:** Failed" >> $GITHUB_STEP_SUMMARY
          fi

          echo "" >> $GITHUB_STEP_SUMMARY
          echo "## Recovery Actions" >> $GITHUB_STEP_SUMMARY
          echo "- Recovery mode activated" >> $GITHUB_STEP_SUMMARY
          echo "- Creating notification for manual intervention" >> $GITHUB_STEP_SUMMARY
          echo "::endgroup::"

      - name: "üìÖ Schedule Re-run"
        run: |
          # Calculate exponential backoff
          DELAY_MINUTES=$((15 * 2 ** (${{ github.run_attempt }} - 1)))
          # Cap at 4 hours
          DELAY_MINUTES=$((DELAY_MINUTES > 240 ? 240 : DELAY_MINUTES))

          NEXT_RETRY=$(date -d "+${DELAY_MINUTES} minutes" "+%H:%M:%S")

          echo "::notice title=Automatic Retry::Scheduled in ${DELAY_MINUTES} minutes (at approximately ${NEXT_RETRY})"
          echo "- **Next automatic retry:** in ${DELAY_MINUTES} minutes (at ${NEXT_RETRY})" >> $GITHUB_STEP_SUMMARY
