name: "🚀 Semantic Release"

# ============================================================
# ⚡ Trigger Configuration
# ============================================================
on:
  push:
    branches:
      - master
    paths-ignore:
      - 'CHANGELOG.md'
      - 'package.json'
      - '*.md'

  workflow_dispatch:
    inputs:
      debug:
        description: "Enable debug logging"
        required: false
        default: "false"
        type: choice
        options:
          - "true"
          - "false"
      dry_run:
        description: "Run in dry-run mode (no actual release)"
        type: boolean
        default: false

# ============================================================
# 🚫 Prevent Redundant Runs
# ============================================================
concurrency:
  group: ${{ github.workflow }}-${{ github.ref }}
  cancel-in-progress: true

# ============================================================
# 🔒 Permissions (Least Privilege Principle)
# ============================================================
permissions:
  contents: write  # For repository updates, Git tags
  issues: write    # For issue comments
  pull-requests: write  # For PR comments
  id-token: write  # For provenance generation (npm best practice)

# ============================================================
# 🌍 Environment Variables
# ============================================================
env:
  GH_TOKEN: ${{ secrets.PAT }}
  NODE_ENV: "production"
  BUN_RUNTIME_SAFETY: "true"
  DEBUG: ${{ github.event.inputs.debug == 'true' && 'semantic-release:*' || '' }}
  DRY_RUN: ${{ github.event.inputs.dry_run == 'true' || 'false' }}
  GIT_AUTHOR_NAME: "GitHub Actions"
  GIT_AUTHOR_EMAIL: "github-actions@github.com"
  GIT_COMMITTER_NAME: "GitHub Actions"
  GIT_COMMITTER_EMAIL: "github-actions@github.com"

# ============================================================
# 🔄 Jobs
# ============================================================
jobs:
  release:
    name: "🚀 Release"
    runs-on: ubuntu-latest
    timeout-minutes: 5

    steps:
      # -------------------------------------------------------
      # 📋 Setup
      # -------------------------------------------------------
      - name: "⬇️ Checkout Repository"
        uses: actions/checkout@v4
        with:
          fetch-depth: 0  # Full history for correct versioning
          persist-credentials: true
          token: ${{ secrets.PAT }}

      - name: "🔍 Initialize Workflow"
        id: init
        run: |
          echo "::group::Environment Information"
          echo "🔹 Repository: ${{ github.repository }}"
          echo "🔹 Branch: ${{ github.ref_name }}"
          echo "🔹 Trigger: ${{ github.event_name }}"
          echo "🔹 Commit: ${{ github.sha }}"
          echo "🔹 Mode: ${{ env.DRY_RUN == 'true' && 'Dry Run' || 'Release' }}"
          echo "🔹 Debug: ${{ github.event.inputs.debug == 'true' && 'Enabled' || 'Disabled' }}"
          echo "::endgroup::"

          # Extract Bun version from package.json
          BUN_VERSION=$(node -e "try { const pkg = require('./package.json'); const pm = pkg.packageManager || ''; const version = pm.match(/bun@(.*)/); console.log(version ? version[1] : '1.2.10'); } catch (e) { console.log('1.2.10'); }")
          echo "bun_version=${BUN_VERSION}" >> $GITHUB_OUTPUT

          # Get last tag for reference
          LAST_TAG=$(git describe --tags --abbrev=0 2>/dev/null || echo "none")
          echo "last_tag=${LAST_TAG}" >> $GITHUB_OUTPUT
          echo "::notice::Last release tag: ${LAST_TAG}"

      # -------------------------------------------------------
      # ⚙️ Runtime Setup
      # -------------------------------------------------------
      - name: "🧰 Setup Bun"
        uses: oven-sh/setup-bun@v2
        with:
          bun-version: ${{ steps.init.outputs.bun_version }}

      - name: "📦 Install Dependencies"
        id: deps
        run: |
          echo "::group::Dependency Installation"
          bun install --frozen-lockfile
          # Verify integrity
          bun audit signatures
          echo "::endgroup::"

      # -------------------------------------------------------
      # 🧪 Validation
      # -------------------------------------------------------
      - name: "🔍 Validate Project"
        id: validate
        if: ${{ env.DRY_RUN != 'true' }}
        run: |
          echo "::group::Project Validation"
          echo "🔹 Running TypeScript checks..."
          bun run type-check

          echo "🔹 Running tests..."
          bun run test:ci
          echo "::endgroup::"

      # -------------------------------------------------------
      # 🔐 GPG Setup for Commit Signing
      # -------------------------------------------------------
      - name: "🔐 Setup GPG for Commit Signing"
        id: gpg-setup
        if: ${{ env.DRY_RUN != 'true' }}
        run: |
          echo "::group::GPG Setup"
          # Only proceed if GPG keys are provided
          if [[ -n "${{ secrets.GPG_PRIVATE_KEY }}" && -n "${{ secrets.GPG_PASSPHRASE }}" ]]; then
            echo "Setting up GPG key for signed commits"

            # Install gnupg if needed
            which gpg > /dev/null || { sudo apt-get update -qq && sudo apt-get install -qq -y gnupg; }

            # Create temporary file for GPG key
            GPG_KEY_FILE=$(mktemp)
            chmod 600 "$GPG_KEY_FILE"
            echo "${{ secrets.GPG_PRIVATE_KEY }}" | base64 -d > "$GPG_KEY_FILE"

            # Import the GPG key
            echo "${{ secrets.GPG_PASSPHRASE }}" | gpg --batch --yes --passphrase-fd 0 --import "$GPG_KEY_FILE"

            # Get the key ID
            KEY_ID=$(gpg --list-secret-keys --keyid-format LONG | grep sec | head -n1 | awk '{print $2}' | cut -d'/' -f2)

            # Configure Git to use the imported GPG key
            git config --global user.signingkey "$KEY_ID"
            git config --global commit.gpgsign true

            # Set commit author identity from secrets
            git config --global user.name "${{ secrets.GIT_COMMITTER_NAME || github.repository_owner }}"
            git config --global user.email "${{ secrets.GIT_COMMITTER_EMAIL }}"

            # Secure cleanup
            rm -f "$GPG_KEY_FILE"

            # Configure GPG for non-interactive environment
            mkdir -p ~/.gnupg
            echo 'allow-loopback-pinentry' > ~/.gnupg/gpg-agent.conf
            echo 'use-agent' > ~/.gnupg/gpg.conf
            echo 'pinentry-mode loopback' >> ~/.gnupg/gpg.conf
            echo 'no-tty' >> ~/.gnupg/gpg.conf
            chmod 700 ~/.gnupg
            gpgconf --kill gpg-agent

            # Export passphrase env var for GPG to use
            export GPG_TTY=$(tty)
            export GNUPGHOME=~/.gnupg
            export GPG_PASSPHRASE="${{ secrets.GPG_PASSPHRASE }}"

            echo "signing_enabled=true" >> $GITHUB_OUTPUT
            echo "key_id=$KEY_ID" >> $GITHUB_OUTPUT
            echo "GPG signing enabled with key: $KEY_ID"
          else
            echo "GPG signing not configured - using standard commits"
            git config --global user.name "${{ env.GIT_AUTHOR_NAME }}"
            git config --global user.email "${{ env.GIT_AUTHOR_EMAIL }}"

            echo "signing_enabled=false" >> $GITHUB_OUTPUT
          fi
          echo "::endgroup::"

      # -------------------------------------------------------
      # 🚀 Semantic Release
      # -------------------------------------------------------
      - name: "🚀 Run Semantic Release"
        id: semantic-release
        env:
          GH_TOKEN: ${{ secrets.PAT }}
          GPG_PASSPHRASE: ${{ secrets.GPG_PASSPHRASE }}
          GPG_SIGNING: ${{ steps.gpg-setup.outputs.signing_enabled }}
          GPG_KEY_ID: ${{ steps.gpg-setup.outputs.key_id }}
        run: |
          echo "::group::Semantic Release Process"

          # Configure release flags based on inputs
          FLAGS=""
          if [[ "${{ env.DRY_RUN }}" == "true" ]]; then
            FLAGS="--dry-run"
            echo "Running in dry-run mode (no actual release)"
          fi

          # Add debug flags if needed
          if [[ "${{ github.event.inputs.debug }}" == "true" ]]; then
            FLAGS="${FLAGS} --debug"
            echo "Debug mode enabled"
          fi

          # Set up GPG for semantic-release to use
          if [[ "$GPG_SIGNING" == "true" ]]; then
            echo "Setting up non-interactive GPG signing for semantic-release..."

            # Create a temporary directory for GPG to use
            GNUPGHOME=$(mktemp -d)
            chmod 700 "$GNUPGHOME"
            export GNUPGHOME

            # Write the GPG config files without using heredoc
            echo "allow-loopback-pinentry" > "$GNUPGHOME/gpg.conf"
            echo "batch" >> "$GNUPGHOME/gpg.conf"
            echo "no-tty" >> "$GNUPGHOME/gpg.conf"
            echo "pinentry-mode loopback" >> "$GNUPGHOME/gpg.conf"

            # Write the agent config
            echo "allow-loopback-pinentry" > "$GNUPGHOME/gpg-agent.conf"
            echo "pinentry-program /bin/true" >> "$GNUPGHOME/gpg-agent.conf"

            # Restart the gpg-agent to apply settings
            gpgconf --kill gpg-agent

            # Set up Git to use custom GPG settings
            git config --global gpg.program "$(which gpg)"
            git config --global commit.gpgsign true

            # Set up environment variable for passphrase
            export GPG_TTY=$(tty || echo /dev/null)

            # Create a git hook to provide the passphrase automatically
            mkdir -p "$(git rev-parse --git-dir)/hooks"
            echo "#!/bin/sh" > "$(git rev-parse --git-dir)/hooks/prepare-commit-msg"
            echo "export GPG_TTY=/dev/null" >> "$(git rev-parse --git-dir)/hooks/prepare-commit-msg"
            echo "echo \"\$GPG_PASSPHRASE\" | gpg --batch --yes --passphrase-fd 0 --pinentry-mode loopback -o /dev/null --sign - 2>/dev/null || true" >> "$(git rev-parse --git-dir)/hooks/prepare-commit-msg"
            chmod +x "$(git rev-parse --git-dir)/hooks/prepare-commit-msg"

            # Create a helper script for GPG passphrase
            echo "#!/bin/sh" > "$GNUPGHOME/pass-helper.sh"
            echo "echo \"\$GPG_PASSPHRASE\"" >> "$GNUPGHOME/pass-helper.sh"
            chmod +x "$GNUPGHOME/pass-helper.sh"

            # Set the GPG passphrase directly
            git config --global gpg.passphrase "$GPG_PASSPHRASE"

            echo "GPG signing is configured for semantic-release commits"
          else
            echo "GPG signing is not configured, commits will not be signed"
          fi

          # Execute semantic-release with Bun
          echo "Executing: bunx semantic-release ${FLAGS}"
          OUTPUT=$(bunx semantic-release ${FLAGS})
          STATUS=$?

          # Store output for inspection
          echo "$OUTPUT" > semantic-release-output.log

          # Handle output
          if [ $STATUS -eq 0 ]; then
            echo "::notice::Semantic release completed successfully"

            # Try to extract the released version from output
            VERSION=$(echo "$OUTPUT" | grep -oP "(?:The next release version is|Published release )\K[0-9]+\.[0-9]+\.[0-9]+" || echo "")

            if [[ -n "$VERSION" ]]; then
              echo "version=${VERSION}" >> $GITHUB_OUTPUT
              echo "::notice::Version v${VERSION} released!"
            elif [[ "${{ env.DRY_RUN }}" == "true" ]]; then
              echo "status=dry-run" >> $GITHUB_OUTPUT
              echo "::notice::Dry run completed successfully"
            else
              echo "status=no-release" >> $GITHUB_OUTPUT
              echo "::notice::No release required - no relevant changes detected"
            fi
          else
            echo "::error::Semantic release failed with exit code $STATUS"
            echo "$OUTPUT" | grep -E "ERR|Error|WARN|Warning" || echo "$OUTPUT" | tail -n 20
            exit $STATUS
          fi

          echo "::endgroup::"

      # -------------------------------------------------------
      # 🔄 Back-Merge & Synchronize Branches
      # -------------------------------------------------------
      - name: "🔄 Back-Merge & Synchronize Branches"
        id: back-merge
        if: steps.semantic-release.outputs.version != '' && env.DRY_RUN != 'true'
        env:
          GH_TOKEN: ${{ secrets.PAT }}
          GPG_PASSPHRASE: ${{ secrets.GPG_PASSPHRASE }}
          SIGNING_ENABLED: ${{ steps.gpg-setup.outputs.signing_enabled }}
        run: |
          echo "::group::Back-Merge and Branch Synchronization"
          echo "🔹 Setting git configuration..."
          if [[ "$SIGNING_ENABLED" == "true" ]]; then
            # GPG is already configured in the previous step
            echo "Using GPG signing for branch synchronization"
          else
            # Standard git configuration without signing
            git config --global user.name "${{ env.GIT_AUTHOR_NAME }}"
            git config --global user.email "${{ env.GIT_AUTHOR_EMAIL }}"
          fi

          # Check if develop branch exists
          echo "🔹 Checking for develop branch..."
          if git show-ref --verify --quiet refs/remotes/origin/develop; then
            echo "✅ Found develop branch"

            echo "🔹 Fetching latest changes from all branches..."
            git fetch origin --prune

            echo "🔹 Ensure we're on master with latest changes..."
            git checkout master
            git pull origin master

            echo "🔹 Getting the latest commit hash from master..."
            MASTER_COMMIT=$(git rev-parse HEAD)
            echo "Master is at commit: $MASTER_COMMIT"

            echo "🔹 Checking out develop branch..."
            git checkout develop
            git pull origin develop

            # Instead of a hard reset, rebase develop on top of master
            # This preserves develop branch changes while incorporating master changes
            echo "🔹 Rebasing develop on top of master instead of hard reset..."
            if [[ "$SIGNING_ENABLED" == "true" ]]; then
              # Use -S flag for signed commits during rebase
              echo "$GPG_PASSPHRASE" | GIT_SEQUENCE_EDITOR=: git -c gpg.passphrase="$GPG_PASSPHRASE" rebase --gpg-sign master
              # Force push with signed commits
              echo "$GPG_PASSPHRASE" | gpg --batch --yes --passphrase-fd 0 --pinentry-mode loopback -o /dev/null --sign - && git push origin develop --force
            else
              # Standard workflow without signing
              GIT_SEQUENCE_EDITOR=: git rebase master
              git push origin develop --force
            fi

            echo "🔹 Verifying develop is ahead or equal to master..."
            git checkout master
            MASTER_HEAD=$(git rev-parse HEAD)
            git checkout develop
            DEVELOP_HEAD=$(git rev-parse HEAD)

            if git merge-base --is-ancestor "$MASTER_HEAD" "$DEVELOP_HEAD"; then
              echo "✅ Success! Develop branch contains all of master's history"
            else
              echo "⚠️ Warning: Develop branch does not contain master's history!"
              echo "Master: $MASTER_HEAD"
              echo "Develop: $DEVELOP_HEAD"
              exit 1
            fi

            # List all branches and delete all except master and develop
            echo "🔹 Cleaning up other branches..."
            git checkout master

            # Delete local branches except master and develop
            for branch in $(git branch | grep -v "master" | grep -v "develop" | tr -d " *"); do
              echo "Deleting local branch: $branch"
              git branch -D $branch
            done

            # Delete remote branches except master and develop
            for branch in $(git branch -r | grep "origin/" | grep -v "origin/master" | grep -v "origin/develop" | sed 's/origin\///'); do
              echo "Deleting remote branch: $branch"
              if [[ "$SIGNING_ENABLED" == "true" ]]; then
                # Use signing for branch deletion
                echo "$GPG_PASSPHRASE" | gpg --batch --yes --passphrase-fd 0 --pinentry-mode loopback -o /dev/null --sign - && git push origin --delete $branch
              else
                git push origin --delete $branch
              fi
            done

            echo "✅ Successfully rebased develop on top of master and cleaned up branches"
            echo "back_merge_status=success" >> $GITHUB_OUTPUT
          else
            echo "⚠️ No develop branch found, skipping synchronization"
            echo "back_merge_status=skipped" >> $GITHUB_OUTPUT
          fi
          echo "::endgroup::"

      # -------------------------------------------------------
      # 📊 Release Summary
      # -------------------------------------------------------
      - name: "📊 Generate Release Summary"
        if: always()
        run: |
          echo "# Semantic Release Results" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY

          # If we have version output, a release happened
          if [[ "${{ steps.semantic-release.outputs.version }}" != "" ]]; then
            echo "✅ **Version ${{ steps.semantic-release.outputs.version }} released successfully**" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY

            # Add signing information
            if [[ "${{ steps.gpg-setup.outputs.signing_enabled }}" == "true" ]]; then
              echo "🔐 **Release commits were signed with GPG**" >> $GITHUB_STEP_SUMMARY
              echo "" >> $GITHUB_STEP_SUMMARY
            fi

            # Add changelog info if available
            if [[ -f "CHANGELOG.md" ]]; then
              echo "## Release Notes" >> $GITHUB_STEP_SUMMARY
              echo "See [CHANGELOG.md](../blob/master/CHANGELOG.md) for detailed release notes." >> $GITHUB_STEP_SUMMARY

              # Extract the latest release notes from CHANGELOG.md
              echo "" >> $GITHUB_STEP_SUMMARY
              echo "### Latest Changes" >> $GITHUB_STEP_SUMMARY
              echo "```" >> $GITHUB_STEP_SUMMARY
              sed -n "/## \[${{ steps.semantic-release.outputs.version }}/,/## \[/p" CHANGELOG.md | sed '1p;/## \[/d' | head -n 15 >> $GITHUB_STEP_SUMMARY
              echo "..." >> $GITHUB_STEP_SUMMARY
              echo "```" >> $GITHUB_STEP_SUMMARY
            fi

          elif [[ "${{ steps.semantic-release.outputs.status }}" == "dry-run" ]]; then
            echo "✅ **Dry run completed successfully**" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "No changes were made to the repository." >> $GITHUB_STEP_SUMMARY

          elif [[ "${{ steps.semantic-release.outputs.status }}" == "no-release" ]]; then
            echo "ℹ️ **No new version released**" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "No changes that would trigger a semantic version bump were detected." >> $GITHUB_STEP_SUMMARY

          elif [[ "${{ job.status }}" != "success" ]]; then
            echo "❌ **Release process failed**" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "Check the workflow logs for more information." >> $GITHUB_STEP_SUMMARY
          fi

          # Add execution stats
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "## Execution Details" >> $GITHUB_STEP_SUMMARY
          echo "- **Repository:** ${{ github.repository }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Branch:** ${{ github.ref_name }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Commit:** [\`${GITHUB_SHA:0:7}\`](../commit/${{ github.sha }})" >> $GITHUB_STEP_SUMMARY
          echo "- **Workflow Run:** [#${{ github.run_number }}](../actions/runs/${{ github.run_id }})" >> $GITHUB_STEP_SUMMARY
          echo "- **Previous Release:** ${{ steps.init.outputs.last_tag }}" >> $GITHUB_STEP_SUMMARY

      # -------------------------------------------------------
      # 📦 Upload Artifacts
      # -------------------------------------------------------
      - name: "📤 Upload Release Output Artifact"
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: semantic-release-output-${{ github.run_id }}
          path: |
            semantic-release-output.log
            CHANGELOG.md
          retention-days: 7
          if-no-files-found: ignore
