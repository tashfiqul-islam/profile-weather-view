#!/usr/bin/env bash
# ==============================================================================
# Pre-commit Validation Script
# Performs automated code quality checks on staged files before allowing commit
# ==============================================================================

# ------------------------------------------------------------------------------
# Configuration
# ------------------------------------------------------------------------------
# Execution and performance settings
MAX_CONCURRENT_JOBS=4
TIME_BUDGET=120
INCREMENTAL_MODE="true"
CACHE_DIR=".git/hooks/cache"
SKIP_PATTERN="EMERGENCY"

# ------------------------------------------------------------------------------
# Terminal Support
# ------------------------------------------------------------------------------
# Detect terminal capabilities for appropriate output formatting
if [ -t 1 ] && command -v tput > /dev/null; then
  SUPPORTS_COLOR=1
  BOLD=$(tput bold)
  GREEN=$(tput setaf 2)
  YELLOW=$(tput setaf 3)
  RED=$(tput setaf 1)
  BLUE=$(tput setaf 4)
  MAGENTA=$(tput setaf 5)
  CYAN=$(tput setaf 6)
  RESET=$(tput sgr0)
else
  # Ensure graceful operation in environments without color support
  SUPPORTS_COLOR=0
  BOLD="" GREEN="" YELLOW="" RED="" BLUE="" MAGENTA="" CYAN="" RESET=""
fi

# ------------------------------------------------------------------------------
# Utility Functions
# ------------------------------------------------------------------------------
# Structured logging with consistent formatting
log() {
  local level=$1
  local message=$2
  local timestamp=$(date +"%H:%M:%S")

  case $level in
    "INFO")  echo -e "${CYAN}${timestamp} ℹ️ ${RESET}${message}" ;;
    "WARN")  echo -e "${YELLOW}${timestamp} ⚠️ ${RESET}${message}" ;;
    "ERROR") echo -e "${RED}${timestamp} ❌ ${RESET}${message}" ;;
    "SUCCESS") echo -e "${GREEN}${timestamp} ✅ ${RESET}${message}" ;;
    *) echo -e "${timestamp} ${message}" ;;
  esac
}

# Process visualization with live feedback
show_spinner() {
  local message=$1
  local pid=$2
  local delay=0.1
  local spinstr='|/-\'

  # Skip animation in non-compatible terminals
  if [ $SUPPORTS_COLOR -eq 0 ]; then
    log "INFO" "${message} (running...)"
    wait $pid
    return $?
  fi

  local start_time=$(date +%s)

  echo -ne "${BLUE}${message} ${RESET}"
  while kill -0 $pid 2>/dev/null; do
    local temp=${spinstr#?}
    local elapsed=$(($(date +%s) - start_time))
    printf " [%c] (%ds)" "$spinstr" "$elapsed"
    local spinstr=$temp${spinstr%"$temp"}
    sleep $delay
    printf "\b\b\b\b\b\b\b\b\b\b\b\b"
  done
  printf "        \b\b\b\b\b\b\b\b"

  wait $pid
  return $?
}

# ------------------------------------------------------------------------------
# Environment Detection
# ------------------------------------------------------------------------------
# Prepare storage for operational data
mkdir -p "$CACHE_DIR"

# Check for special commit conditions
COMMIT_MSG=$(git log -1 --pretty=%B 2>/dev/null || echo "")
if echo "$COMMIT_MSG" | grep -q "$SKIP_PATTERN"; then
  log "WARN" "Emergency commit detected. Bypassing validation checks."
  exit 0
fi

# Respect CI environment conventions
if [ -n "$CI" ]; then
  log "INFO" "CI environment detected, skipping pre-commit hooks"
  exit 0
fi

# Start performance tracking
START_TIME=$(date +%s)

# ------------------------------------------------------------------------------
# File Selection
# ------------------------------------------------------------------------------
# Retrieve staged files efficiently
get_staged_files() {
  git diff --cached --name-only --diff-filter=ACMR
}

# Collect and filter relevant files
ALL_STAGED_FILES=$(get_staged_files)

if [ -z "$ALL_STAGED_FILES" ]; then
  log "WARN" "No files staged for commit. Nothing to validate."
  exit 0
fi

# Select files for validation based on extension patterns
STAGED_FILES=$(echo "$ALL_STAGED_FILES" | grep -E '\.(ts|tsx|js|jsx|json)$' || echo "")

if [ -z "$STAGED_FILES" ]; then
  log "INFO" "No relevant code files to validate in this commit."
  exit 0
fi

# ------------------------------------------------------------------------------
# Validation Pipeline
# ------------------------------------------------------------------------------
log "INFO" "${BOLD}Initiating validation pipeline${RESET}"
echo "$STAGED_FILES" | sort | uniq > "$CACHE_DIR/current_staged_files.txt"

# Track validation status for comprehensive reporting
declare -a VALIDATION_RESULTS=()
PIPELINE_STATUS=0

# Execute individual validation tasks with consistent error handling
run_validation() {
  local name=$1
  local icon=$2
  local cmd=$3
  local files=$4

  # Skip unnecessary processing
  if [ -z "$files" ]; then
    VALIDATION_RESULTS+=("$name: SKIPPED (no files)")
    return 0
  fi

  log "INFO" "Running ${icon} ${BOLD}${name}${RESET}..."

  # Execute asynchronously with output capture
  eval "$cmd" > "$CACHE_DIR/${name}_output.log" 2>&1 &
  local cmd_pid=$!

  # Provide visual feedback during execution
  show_spinner "Executing ${name}" $cmd_pid
  local status=$?

  # Process and record results
  if [ $status -eq 0 ]; then
    log "SUCCESS" "${icon} ${BOLD}${name}${RESET} passed"
    VALIDATION_RESULTS+=("$name: PASSED")
  else
    log "ERROR" "${icon} ${BOLD}${name}${RESET} failed"
    log "ERROR" "See details: ${YELLOW}cat $CACHE_DIR/${name}_output.log${RESET}"
    VALIDATION_RESULTS+=("$name: FAILED")
    PIPELINE_STATUS=1
  fi

  return $status
}

# Format validation
PRETTIER_CMD="echo \"$STAGED_FILES\" | xargs bun run prettier --check --cache --cache-location=$CACHE_DIR/.prettierrc"
run_validation "Code Formatting" "🖌️" "$PRETTIER_CMD" "$STAGED_FILES"

# Static analysis
ESLINT_CMD="echo \"$STAGED_FILES\" | xargs bun run eslint --cache --cache-location=$CACHE_DIR/.eslintcache"
run_validation "Linting" "🧹" "$ESLINT_CMD" "$STAGED_FILES"

# Type checking
TS_CMD="bun run type-check"
run_validation "Type Checking" "📘" "$TS_CMD" "$STAGED_FILES"

# Test execution
AFFECTED_MODULES=$(echo "$STAGED_FILES" | grep -o -E "src/[a-zA-Z0-9_-]+" | sort | uniq)
TEST_CMD="bun run test:staged"
run_validation "Testing" "🧪" "$TEST_CMD" "$STAGED_FILES"

# ------------------------------------------------------------------------------
# Results Reporting
# ------------------------------------------------------------------------------
TOTAL_TIME=$(($(date +%s) - START_TIME))

# Present validation outcomes
echo
log "INFO" "${BOLD}Validation Results${RESET}"
echo "${MAGENTA}━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━${RESET}"
for result in "${VALIDATION_RESULTS[@]}"; do
  if [[ $result == *": PASSED"* ]]; then
    log "SUCCESS" "$result"
  elif [[ $result == *": SKIPPED"* ]]; then
    log "INFO" "$result"
  else
    log "ERROR" "$result"
  fi
done
echo "${MAGENTA}━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━${RESET}"
log "INFO" "Execution time: ${CYAN}${TOTAL_TIME}s${RESET}"

# Provide context-sensitive guidance
if [ $TOTAL_TIME -gt 10 ]; then
  log "INFO" "Tip: For faster commits, consider using ${YELLOW}git add --patch${RESET} to stage fewer files"
fi

# Final status determination
if [ $PIPELINE_STATUS -ne 0 ]; then
  echo
  log "ERROR" "${BOLD}Pre-commit validation failed. Please fix the issues before committing.${RESET}"
  log "INFO" "To bypass validation in an emergency: ${YELLOW}git commit -m \"EMERGENCY: your message\"${RESET}"
  exit 1
else
  echo
  log "SUCCESS" "${BOLD}All validation checks passed!${RESET}"
fi

exit 0
